<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    Kevin&#39;s blog</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="jumbotron">
  <div class="video">
    
      <div class="video-frame">
        <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
      </div>
    
    <div class="video-media">
      <video playsinline="" autoplay="" loop="" muted="" data-autoplay=""
             poster="/images/ocean/ocean.png" x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">Kevin&#39;s blog</a></h1>
      <p></p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="Kevin&#39;s blog"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>

<div id="landingpage">
  <section class="outer">
  <article class="articles">
    
    <h1 class="page-type-title"></h1>

    
      
        <article id="post-从mysql索引谈b树和b+树" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/08/08/从mysql索引谈b树和b+树/">从mysql索引谈b树和b+树</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/08/08/从mysql索引谈b树和b+树/" class="article-date">
  <time datetime="2019-08-08T13:31:12.000Z" itemprop="datePublished">2019-08-08</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h1 id="一，mysql索引"><a href="#一，mysql索引" class="headerlink" title="一，mysql索引"></a>一，mysql索引</h1><p>mysql对索引的定义就是：索引是帮助高效获取数据的数据结构，</p>
<h2 id="1-mysql中索引的使用"><a href="#1-mysql中索引的使用" class="headerlink" title="1.mysql中索引的使用"></a>1.mysql中索引的使用</h2><h3 id="mysql索引类型"><a href="#mysql索引类型" class="headerlink" title="mysql索引类型"></a>mysql索引类型</h3><p><strong>普通索引</strong></p>
<ul>
<li>其实就是普通的键，能加快查询速度 </li>
</ul>
<p><strong>唯一索引</strong></p>
<ul>
<li>加快查询，但是索引列值必须唯一，可以为null</li>
</ul>
<p><strong>主键索引</strong></p>
<ul>
<li>唯一索引的特例，列值不可为null</li>
</ul>
<p><strong>全文索引</strong></p>
<ul>
<li>对文本内容进行查询时，能加快速度</li>
</ul>
<p><strong>单列索引</strong></p>
<ul>
<li>就是常见的一个列字段的索引</li>
</ul>
<p><strong>组合索引</strong></p>
<ul>
<li>多个列字段组成一个索引，在组合搜索中效率快</li>
</ul>
<h3 id="mysql中的索引操作"><a href="#mysql中的索引操作" class="headerlink" title="mysql中的索引操作"></a>mysql中的索引操作</h3><p>1.创建索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建普通索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> table_name(col_name)</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建唯一索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> table_name(col_name)</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建组合索引</span></span><br><span class="line"><span class="comment">--遵循“最左前缀”原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引相当于建立了col1,col1col2,col1col2col3三个索引，而col2或者col3是不能使用索引的。</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> table_name(col_name1,col_name2,col_name3)</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建唯一组合索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> table_name(col_name1,col_name2)</span><br></pre></td></tr></table></figure>

<p>2.通过修改表结构创建索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">index</span> index_name(col_name) </span><br><span class="line"></span><br><span class="line"><span class="comment">--创建全文索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> FULLTEXT <span class="keyword">INDEX</span> ft_index(<span class="string">'col'</span>)；</span><br></pre></td></tr></table></figure>

<p>3.删除索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> table_name</span><br></pre></td></tr></table></figure>

<h1 id="二，mysql索引底层数据结构"><a href="#二，mysql索引底层数据结构" class="headerlink" title="二，mysql索引底层数据结构"></a>二，mysql索引底层数据结构</h1><p>mysql中的索引是在存储引擎中实现的而不是在服务器端实现的，所以，不同存储引擎支持的索引可能也会有所不同</p>
<p>我们在开头就提到，索引是mysql高效获取数据的数据结构，也就是说，索引其实归根揭底也是一种数据结构</p>
<h2 id="1-猜想索引的数据结构"><a href="#1-猜想索引的数据结构" class="headerlink" title="1.猜想索引的数据结构"></a>1.猜想索引的数据结构</h2><p>索引绝大多数情况都是用在查询操作当中，那么我们列举下我们知道的查找算法</p>
<p><strong>1. 顺序查找？</strong></p>
<pre><code>顺序查找复杂度是O(n)，在数据大的情况下，这种算法的查询表现是十分糟糕的</code></pre><p><strong>2. 二叉树查找？</strong></p>
<pre><code>如果是二叉搜索树：有可能会出现深度过大的左偏树或者右偏树，这样时间复杂度就会有O(logN)变为O(N)

如果是二叉搜索树的进化版平衡二叉树又或者红黑数呢：在数据量大的情况下，基于两个子树的二叉树还是会显得深度过大</code></pre><p><strong>3.多叉树？</strong></p>
<pre><code>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构</code></pre><h2 id="2-基于多叉树的索引实现"><a href="#2-基于多叉树的索引实现" class="headerlink" title="2.基于多叉树的索引实现"></a>2.基于多叉树的索引实现</h2><p>在mysql中不同存储引擎对索引的实现也不同，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p>
<h3 id="MyIsam索引实现（非聚集索引）"><a href="#MyIsam索引实现（非聚集索引）" class="headerlink" title="MyIsam索引实现（非聚集索引）"></a>MyIsam索引实现（非聚集索引）</h3><p>MyIsam引擎使用B+树来实现索引，在B+树的叶子节点数据域中存放的mysql表数据记录的地址</p>
<p><img src="https://img-blog.csdnimg.cn/20190809210653928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20190809210820897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在进行sql查询时，会根据查询语句中的索引条件，在b+树中找到相应的叶子节点，取出相应的数据地址，然后获取相关表记录</p>
<h3 id="innerDB索引实现（聚集索引）"><a href="#innerDB索引实现（聚集索引）" class="headerlink" title="innerDB索引实现（聚集索引）"></a>innerDB索引实现（聚集索引）</h3><p>虽然innerDB也使用b+树作为索引结构，但是实现方式和myisam不同</p>
<p>在主索引中，b+树叶子节点数据域中存储的是数据库表相关列的完整记录</p>
<p><img src="https://img-blog.csdnimg.cn/20190809211253940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>在辅助索引中，b+树叶子节点存储的是主键的值</p>
<p><img src="https://img-blog.csdnimg.cn/20190809211347423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>这种就是聚集索引</p>
<ul>
<li><p>聚集索引在进行主索引查询时效率很高，直接找到相关叶子节点就可以找到相关数据记录，非聚集索引还需要根据数据地址去寻找数据记录</p>
</li>
<li><p>但是聚集索引在辅助索引查询时效率低非聚集索引低，因为需要检索两次b+树，第一次找到主键值，第二次根据主键值找到相关记录</p>
</li>
</ul>
<h3 id="innerDB和myIsam的区别"><a href="#innerDB和myIsam的区别" class="headerlink" title="innerDB和myIsam的区别"></a>innerDB和myIsam的区别</h3><p>||myIsam|innerDB|<br>|–|–|–|–|<br>|索引类型|非聚集索引|聚集索引<br>|索引底层结构|b+树|b树<br>|是否支持事务|否|是<br>|是否支持表锁|是|是<br>|是否支持行数|否|是<br>|是否支持外键|否|是<br>|是否支持全文索引|是|是<br>|是否支持hash索引|否|否<br>|适用操作|大量select|大量insert、delete和update下</p>
<h1 id="三，补充"><a href="#三，补充" class="headerlink" title="三，补充"></a>三，补充</h1><h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>只有memory（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能，但是hash适用于 = 或者 in的等值查询</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kevin091827.github.io/2019/08/08/从mysql索引谈b树和b+树/" data-id="cjz54ryev0005kwu3klofdxoy"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/">mysql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构和算法/">数据结构和算法</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-字符串匹配KMP" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/08/08/字符串匹配KMP/">字符串匹配KMP</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/08/08/字符串匹配KMP/" class="article-date">
  <time datetime="2019-08-08T12:30:24.000Z" itemprop="datePublished">2019-08-08</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h1 id="1-字符串匹配问题"><a href="#1-字符串匹配问题" class="headerlink" title="1.字符串匹配问题"></a>1.字符串匹配问题</h1><p><strong>何为字符串匹配问题？</strong></p>
<p>字符串匹配问题则是，给出一个模式串和一个文本串，需要找出模式串是文本串的子串且模式串在文本串开始的位置</p>
<h1 id="2-暴力解法"><a href="#2-暴力解法" class="headerlink" title="2.暴力解法"></a>2.暴力解法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴力解法</span></span><br><span class="line"><span class="comment"> * O(MN)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> txt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pat</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">forceSearch</span><span class="params">(String txt,String pat)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> txtLen = txt.length();</span><br><span class="line">    <span class="keyword">int</span> patLen = pat.length();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; txtLen &amp;&amp; j &lt; patLen)&#123;</span><br><span class="line">        <span class="comment">//逐一比对</span></span><br><span class="line">        <span class="keyword">if</span>(txt.charAt(i) == pat.charAt(j))&#123;</span><br><span class="line">            <span class="comment">//比对成功，继续向后</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//比对失败，j回到模式串开始，i回到上一次比对位置的下一个位置</span></span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            i = i - j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == patLen)&#123;</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-kmp模式匹配算法"><a href="#3-kmp模式匹配算法" class="headerlink" title="3.kmp模式匹配算法"></a>3.kmp模式匹配算法</h1><h2 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h2><h3 id="1-模式串标上序号"><a href="#1-模式串标上序号" class="headerlink" title="1.模式串标上序号"></a>1.模式串标上序号</h3><p><img src="https://img-blog.csdnimg.cn/20190809140932929.png" alt="在这里插入图片描述"></p>
<h3 id="2-把模式串的所有子串列举出来"><a href="#2-把模式串的所有子串列举出来" class="headerlink" title="2.把模式串的所有子串列举出来"></a>2.把模式串的所有子串列举出来</h3><p><img src="https://img-blog.csdnimg.cn/20190809141034537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="3-把模式串中相等的前缀和后缀的长度求出来"><a href="#3-把模式串中相等的前缀和后缀的长度求出来" class="headerlink" title="3.把模式串中相等的前缀和后缀的长度求出来"></a>3.把模式串中相等的前缀和后缀的长度求出来</h3><p>前缀：除了最后一个字符外，一个字符串所有头部字符的集合</p>
<p>后缀：除了第一个字符外，一个字符串所有的尾部字符的集合</p>
<p>例如：最大相等前缀和后缀长度为2</p>
<p><img src="https://img-blog.csdnimg.cn/20190809141406764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190809141627830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>这样我们求出了一个相等最长前缀和后缀的长度集合maxl</p>
<p><img src="https://img-blog.csdnimg.cn/20190809141826210.png" alt="在这里插入图片描述"></p>
<p>next数组就是相当于最大长度集合集体向右移动一位，数组第一位赋值为-1</p>
<p><img src="https://img-blog.csdnimg.cn/20190809142004725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找前缀后缀最长公共元素长度</span></span><br><span class="line"><span class="comment"> * 获取next数组，告知下一次应该跳到模式串的哪一个位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> patStr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">(String patStr,<span class="keyword">int</span>[] next)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = patStr.length();</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; length - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == -<span class="number">1</span> || patStr.charAt(k) == patStr.charAt(j))&#123;</span><br><span class="line">            ++k;</span><br><span class="line">            ++j;</span><br><span class="line">            next[j] = k;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;next.length;i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"----&gt;"</span> +next[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>接下来有了next数组就可以进行模式匹配了</p>
<h3 id="1-模式串和文本串从第一个字符开始比较，相等则，指针移到模式串和文本串的下一个字符"><a href="#1-模式串和文本串从第一个字符开始比较，相等则，指针移到模式串和文本串的下一个字符" class="headerlink" title="1.模式串和文本串从第一个字符开始比较，相等则，指针移到模式串和文本串的下一个字符"></a>1.模式串和文本串从第一个字符开始比较，相等则，指针移到模式串和文本串的下一个字符</h3><p><img src="https://img-blog.csdnimg.cn/20190809142555907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-当不匹配时，将字串中索引为0的元素移到不匹配元素的位置，其他元素移动相同的距离"><a href="#2-当不匹配时，将字串中索引为0的元素移到不匹配元素的位置，其他元素移动相同的距离" class="headerlink" title="2.当不匹配时，将字串中索引为0的元素移到不匹配元素的位置，其他元素移动相同的距离"></a>2.当不匹配时，将字串中索引为0的元素移到不匹配元素的位置，其他元素移动相同的距离</h3><p><img src="https://img-blog.csdnimg.cn/20190809142909709.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190809143015773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="3-当出现这个前面连续几个比对成功，突然出现一个匹配失败时，则将模式串移到以匹配不成功元素对应next数组的元素为索引所在的位置，因为前面的相等前缀，无需重复比较"><a href="#3-当出现这个前面连续几个比对成功，突然出现一个匹配失败时，则将模式串移到以匹配不成功元素对应next数组的元素为索引所在的位置，因为前面的相等前缀，无需重复比较" class="headerlink" title="3.当出现这个前面连续几个比对成功，突然出现一个匹配失败时，则将模式串移到以匹配不成功元素对应next数组的元素为索引所在的位置，因为前面的相等前缀，无需重复比较"></a>3.当出现这个前面连续几个比对成功，突然出现一个匹配失败时，则将模式串移到以匹配不成功元素对应next数组的元素为索引所在的位置，因为前面的相等前缀，无需重复比较</h3><p><img src="https://img-blog.csdnimg.cn/20190809143131289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190809143231315.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="4-直到匹配成功"><a href="#4-直到匹配成功" class="headerlink" title="4.直到匹配成功"></a>4.直到匹配成功</h3><p><img src="https://img-blog.csdnimg.cn/20190809143705948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="5-完整代码实现"><a href="#5-完整代码实现" class="headerlink" title="5.完整代码实现"></a>5.完整代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * KMP</span></span><br><span class="line"><span class="comment"> * O(m+n) m:字符串长度，n：next数组长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> txt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pat</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmpSearch</span><span class="params">(String txt,String pat,<span class="keyword">int</span>[] next)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> txtLen = txt.length();</span><br><span class="line">    <span class="keyword">int</span> patLen = pat.length();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; txtLen &amp;&amp; j &lt; patLen)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span> || txt.charAt(i) == pat.charAt(j))&#123;</span><br><span class="line">            j++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == patLen)&#123;</span><br><span class="line">        <span class="keyword">return</span> i - j;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找前缀后缀最长公共元素长度</span></span><br><span class="line"><span class="comment"> * 获取next数组，告知下一次应该跳到模式串的哪一个位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> patStr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">(String patStr,<span class="keyword">int</span>[] next)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = patStr.length();</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; length - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == -<span class="number">1</span> || patStr.charAt(k) == patStr.charAt(j))&#123;</span><br><span class="line">            ++k;</span><br><span class="line">            ++j;</span><br><span class="line">            next[j] = k;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;next.length;i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"----&gt;"</span> +next[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://kevin091827.github.io/2019/08/08/字符串匹配KMP/" data-id="cjz54ryff000hkwu30rztc3ha"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构和算法/">数据结构和算法</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-线索二叉树" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/08/07/线索二叉树/">线索二叉树</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/08/07/线索二叉树/" class="article-date">
  <time datetime="2019-08-07T13:47:42.000Z" itemprop="datePublished">2019-08-07</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h1 id="1-为什么会出现线索二叉树？"><a href="#1-为什么会出现线索二叉树？" class="headerlink" title="1.为什么会出现线索二叉树？"></a>1.为什么会出现线索二叉树？</h1><p>当我们使用链式存储结构来构造二叉树时，我们可以很方便的找到某个节点的左右子节点，但是，在一般情况下，我们却无法直接找到某个节点在某种遍历序列中的前驱和后继节点</p>
<p><strong>如何解决这个问题？</strong></p>
<ol>
<li>通过遍历寻找 —— 费时间</li>
<li>再增设两个域存储前驱和后继节点 ——- 非空间</li>
<li>线索化</li>
</ol>
<h1 id="2-线索化"><a href="#2-线索化" class="headerlink" title="2.线索化"></a>2.线索化</h1><p>我们知道，具有n个节点的二叉树中，一共有2n个指针域。n个节点有n-1个孩子，所有在2n个指针域中，有n-1个用来表示节点的左右孩子，还有n+1个指针域为空，没有使用</p>
<p>我们可以利用这些空指针域实现线索化</p>
<p>如果某个节点的左孩子为空。则将空的左孩子指针域改为指向遍历序列前驱的指针域，右孩子为空，则将空的右孩子指针域改造为指向遍历序列后继的指针域</p>
<p>这种改变指向，就称为线索化</p>
<p>加上线索的二叉树，就是线索二叉树</p>
<p>对二叉树按某种遍历次序使其变为线索二叉树的过程就是线索化</p>
<p><img src="https://img-blog.csdnimg.cn/2019080722094591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>线索化后</p>
<p><img src="https://img-blog.csdnimg.cn/20190807221021985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>代码实现</p>
<p>中序线索化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序线索化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inThreadOrder</span><span class="params">(ThreadedTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归线索化左子树</span></span><br><span class="line">    inThreadOrder(node.left);</span><br><span class="line">    <span class="comment">//此时 node节点的左右标志位均为false，代表的左右子节点</span></span><br><span class="line">    <span class="comment">//如果左子节点为空</span></span><br><span class="line">    <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//赋值为遍历序列的前驱节点</span></span><br><span class="line">        node.left = preNode;</span><br><span class="line">        <span class="comment">//设置标志位</span></span><br><span class="line">        node.leftIsThreaded = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同样道理处理遍历序列的前驱的节点的后继节点为node节点</span></span><br><span class="line">    <span class="keyword">if</span>(preNode != <span class="keyword">null</span> &amp;&amp; preNode.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">        preNode.right = node;</span><br><span class="line">        preNode.rightIsThread = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    preNode = node;</span><br><span class="line">    <span class="comment">//递归线索化右子节点</span></span><br><span class="line">    inThreadOrder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前序线索化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序线索化二叉树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preThreadOrder</span><span class="params">(ThreadedTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时 node节点的左右标志位均为false，代表的左右子节点</span></span><br><span class="line">    <span class="comment">//如果左子节点为空</span></span><br><span class="line">    <span class="keyword">if</span>(node.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//赋值为遍历序列的前驱节点</span></span><br><span class="line">        node.left = preNode;</span><br><span class="line">        <span class="comment">//设置标志位</span></span><br><span class="line">        node.leftIsThreaded = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同样道理处理遍历序列的前驱的节点的后继节点为node节点</span></span><br><span class="line">    <span class="keyword">if</span>(preNode != <span class="keyword">null</span> &amp;&amp; preNode.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">        preNode.right = node;</span><br><span class="line">        preNode.rightIsThread = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    preNode = node;</span><br><span class="line">    <span class="comment">//递归线索化左子树</span></span><br><span class="line">    <span class="keyword">if</span>(!node.leftIsThreaded)&#123;</span><br><span class="line">        inThreadOrder(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归线索化右子节点</span></span><br><span class="line">    <span class="keyword">if</span>(!node.rightIsThread) &#123;</span><br><span class="line">        inThreadOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-遍历线索树"><a href="#3-遍历线索树" class="headerlink" title="3.遍历线索树"></a>3.遍历线索树</h1><p>前序遍历线索树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历线索二叉树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(ThreadedTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不断寻找前驱，找到第一个</span></span><br><span class="line">    <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node.leftIsThreaded)&#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    System.out.println(node.val);</span><br><span class="line">    node = node.right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后序遍历线索树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历线索二叉树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(ThreadedTreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1、找最后一个节点</span></span><br><span class="line">    <span class="keyword">while</span>(node.right != <span class="keyword">null</span> &amp;&amp; !node.rightIsThread) &#123;</span><br><span class="line">        node = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        System.out.println(node.val);</span><br><span class="line">        <span class="comment">//判断是否是线索</span></span><br><span class="line">        <span class="keyword">if</span>(!node.leftIsThreaded)&#123;</span><br><span class="line">            <span class="comment">//是线索，继续往前遍历</span></span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//不是线索,找到左子树开始的节点</span></span><br><span class="line">            node = node.left;</span><br><span class="line">            <span class="keyword">while</span>(!node.rightIsThread &amp;&amp; node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了线索树，我们可以更加快捷的找到某节点在某种遍历下的前驱和后继节点</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kevin091827.github.io/2019/08/07/线索二叉树/" data-id="cjz54ryg2000wkwu32dn0ne1c"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构和算法/">数据结构和算法</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-单值二叉树" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/08/06/单值二叉树/">单值二叉树</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/08/06/单值二叉树/" class="article-date">
  <time datetime="2019-08-06T14:38:53.000Z" itemprop="datePublished">2019-08-06</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <p>如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。</p>
<p>只有给定的树是单值二叉树时，才返回 true；否则返回 false。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/screen-shot-2018-12-25-at-50104-pm.png" alt></p>
<pre><code>输入：[1,1,1,1,1,null,1]
输出：true</code></pre><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/screen-shot-2018-12-25-at-50050-pm.png" alt></p>
<pre><code>输入：[2,2,2,5,2]
输出：false</code></pre><p>若为单值二叉树，则所有节点的值和根节点的值是一样的，所以，先拿到根节点的值，递归比较左子节点和右子节点        </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">// public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">//       int val;</span></span><br><span class="line"><span class="comment">//       TreeNode left;</span></span><br><span class="line"><span class="comment">//       TreeNode right;</span></span><br><span class="line"><span class="comment">//       TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnivalTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(root,root.val);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(TreeNode node,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(val != node.val)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">return</span> check(node.left,val)&amp;&amp;check(node.right,val);</span><br><span class="line">      </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://kevin091827.github.io/2019/08/06/单值二叉树/" data-id="cjz54ryf10009kwu399jrt3a4"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构和算法/">数据结构和算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/递归/">递归</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-java8-stream" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/08/06/java8-stream/">java8 stream</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/08/06/java8-stream/" class="article-date">
  <time datetime="2019-08-06T14:05:57.000Z" itemprop="datePublished">2019-08-06</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h1 id="一，stream概述"><a href="#一，stream概述" class="headerlink" title="一，stream概述"></a>一，stream概述</h1><p><strong>什么是stream？</strong></p>
<p>这里的stream不同于IO中的inputStream和OutputStream，stream位于java.util.stream中，是一组支持串行并行聚合操作的元素，也可以理解成集合或者迭代器的增强版</p>
<p><strong>特征：</strong></p>
<ul>
<li><p>单次处理，一次处理结束后，当前stream就关闭了</p>
</li>
<li><p>支持并行操作</p>
</li>
</ul>
<h1 id="二，使用"><a href="#二，使用" class="headerlink" title="二，使用"></a>二，使用</h1><ul>
<li><p><strong>allMatch和anyMatch</strong></p>
<p>  allMatch：检查 Stream 中的所有元素，全部都通过检测则返回 true，否则 false</p>
<p>  anyMatch：检查 Stream 中的所有元素，至少有一个通过检测则返回 true，否则 false </p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//allMatch</span></span><br><span class="line">System.out.println(<span class="string">"-----&gt;"</span>+list.stream().allMatch(n-&gt;n.getClass() == Integer.class));</span><br><span class="line"><span class="comment">//anyMatch</span></span><br><span class="line">System.out.println(<span class="string">"-----&gt;"</span>+list.stream().anyMatch(n-&gt;n&gt;<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>max，min和sort</strong></p>
<p>  max：返回stream中的最大值</p>
<p>  min：返回stream中的最小值</p>
<p>  sort：对stream中的元素排序</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历</span></span><br><span class="line">list.stream().forEach(a -&gt; System.out.println(a));</span><br><span class="line"><span class="comment">//max</span></span><br><span class="line">System.out.println(<span class="string">"-----&gt;"</span>+list.stream().max((a,b)-&gt;a-b).get());</span><br><span class="line"><span class="comment">//min</span></span><br><span class="line">System.out.println(<span class="string">"-----&gt;"</span>+list.stream().min((a,b)-&gt;a-b).get());</span><br><span class="line"><span class="comment">//sort</span></span><br><span class="line">list.stream().sorted((a,b)-&gt;a-b).forEach(a-&gt;System.out.println(a));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>filter和map</strong></p>
<p>  filter：筛选 Stream 元素，符合条件的留下并组成一个新的 Stream 。</p>
<p>  map：依次对 Stream 中的元素进行指定的函数操作，并将按顺序将函数操作的返回值组合到一个新的 Stream 中。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//筛选filter</span></span><br><span class="line">list.stream().filter(n-&gt;n&gt;<span class="number">6</span>).forEach(n-&gt;System.out.println(n));</span><br><span class="line"><span class="comment">//map</span></span><br><span class="line">list.stream().map(n-&gt;n+<span class="number">1</span>).forEach(n-&gt;System.out.println(n));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>distinct和collect</strong></p>
<p>  distinct：去重</p>
<p>  collect：可以做collectors中的一些操作，如：连接，转list，分组等</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//collect</span></span><br><span class="line">Stream.of(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>).collect(Collectors.toList()).forEach(n-&gt;System.out.println(n));</span><br><span class="line"><span class="comment">//去重distinct</span></span><br><span class="line">Stream.of(<span class="string">"2"</span>,<span class="string">"2"</span>,<span class="string">"2"</span>).distinct().forEach(n-&gt;System.out.println(n));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>还有很多详细的用法，没有举出，可以参考：</p>
<p><a href="https://buzheng.org/post/20160226-java-stream-api-notes/" target="_blank" rel="noopener">stream api</a></p>
<h1 id="三-Optional类"><a href="#三-Optional类" class="headerlink" title="三,Optional类"></a>三,Optional类</h1><p>Optional类是java8新增的一个类，用以解决程序中常见的NullPointerException异常问题</p>
<p>NullPointerException是我们很经常遇到的一个问题，大多人遇到这个异常的时候，可能会在出现异常的代码处添加if-else的判断，类似下边代码；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindUserToRole</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String roleId = user.getRoleId();</span><br><span class="line">        <span class="keyword">if</span> (roleId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Role role = roleDao.findOne(roleId);</span><br><span class="line">            <span class="keyword">if</span> (role != <span class="keyword">null</span>) &#123;</span><br><span class="line">                role.setUserId(user.getUserId());</span><br><span class="line">                roleDao.save(role);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，这样手动处理null，如果数据增多，那么，相应的判断也会增多，业务逻辑就会被这大量的if判断淹没，对于代码维护和可读性是很打击的</p>
<p>在java8推出的Optional类就是用以避免null值引发的种种问题</p>
<h2 id="1-概况："><a href="#1-概况：" class="headerlink" title="1.概况："></a>1.概况：</h2><p>java.util.Optional<t>类是一个封装了Optional值的容器对象，Optional值可以为null，如果值存在，调用isPresent()方法返回true，调用get()方法可以获取值。</t></p>
<h2 id="2-创建Optional对象"><a href="#2-创建Optional对象" class="headerlink" title="2.创建Optional对象"></a>2.创建Optional对象</h2><p>Optional类提供类三个方法用于实例化一个Optional对象，它们分别为empty()、of()、ofNullable()，这三个方法都是静态方法，可以直接调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> T value;<span class="comment">//Optional维护的值</span></span><br></pre></td></tr></table></figure>

<p>默认构造：(主要处理null值)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有参构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Objects.requireNonNull(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>empty()方法用于创建一个没有值的Optional对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>empty()方法创建的对象没有值，如果对emptyOpt变量调用isPresent()方法会返回false，调用get()方法抛出NullPointerException异常。</p>
<p>of()方法使用一个非空的值创建Optional对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">of</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Optional&lt;&gt;(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-接收值"><a href="#3-接收值" class="headerlink" title="3.接收值"></a>3.接收值</h2><p>ofNullable()方法接收一个可以为null的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; nullableOpt = Optional.ofNullable(str);</span><br></pre></td></tr></table></figure>

<p>如果str的值为null，得到的nullableOpt是一个没有值的Optional对象。<br>源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据值是否为null，调用相应构造方法构造相应Optional对象</span></span><br><span class="line">    <span class="keyword">return</span> value == <span class="keyword">null</span> ? empty() : of(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-获取Optional对象中的值"><a href="#4-获取Optional对象中的值" class="headerlink" title="4.获取Optional对象中的值"></a>4.获取Optional对象中的值</h3><p>如果我们要获取User对象中的roleId属性值，常见的方式是直接获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String roleId = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">    roleId = user.getRoleId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制代码使用Optional中提供的map()方法可以以更简单的方式实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;User&gt; userOpt = Optional.ofNullable(user);</span><br><span class="line">Optional&lt;String&gt; roleIdOpt = userOpt.map(User::getRoleId);</span><br></pre></td></tr></table></figure>

<p>Optional类还包含其他方法用于获取值，这些方法分别为：</p>
<ul>
<li>orElse()：如果有值就返回，否则返回一个给定的值作为默认值；</li>
<li>orElseGet()：与orElse()方法作用类似，区别在于生成默认值的方式不同。该方法接受一个Supplier&lt;? extends T&gt;函数式接口参数，用于生成默认值；</li>
<li>orElseThrow()：与前面介绍的get()方法类似，当值为null时调用这两个方法都会抛出NullPointerException异常，区别在于该方法可以指定抛出的异常类型。</li>
</ul>
<h3 id="5-简单应用"><a href="#5-简单应用" class="headerlink" title="5.简单应用"></a>5.简单应用</h3><p><strong>简化if-else</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">User user = ...</span><br><span class="line"><span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">    String userName = user.getUserName();</span><br><span class="line">    <span class="keyword">if</span> (userName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> userName.toUpperCase();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User user = ...</span><br><span class="line">Optional&lt;User&gt; userOpt = Optional.ofNullable(user);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> userOpt.map(User::getUserName)</span><br><span class="line">            .map(String::toUpperCase)</span><br><span class="line">            .orElse(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li><p>尽量避免在程序中直接调用Optional对象的get()和isPresent()方法，直接调用get()方法是很危险的做法，如果Optional的值为空，那么毫无疑问会抛出NullPointerException异常，而为了调用get()方法而使用isPresent()方法作为空值检查，这种做法与传统的用if语句块做空值检查没有任何区别。</p>
</li>
<li><p>避免使用Optional类型声明实体类属性，Optional没有实现Serializable序列化接口 </p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kevin091827.github.io/2019/08/06/java8-stream/" data-id="cjz54ryeo0002kwu3qrubnr9h"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java基础/">java基础</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-java8新特性-lambda表达式" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/08/06/java8新特性-lambda表达式/">java8新特性 lambda表达式</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/08/06/java8新特性-lambda表达式/" class="article-date">
  <time datetime="2019-08-06T10:29:06.000Z" itemprop="datePublished">2019-08-06</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <p>lambda表达式是java8新引入的一个新的新特性，类似于js中的闭包，目的就是提供一个类似函数式编程的语法来简化我们的编码</p>
<h2 id="一，lambda基本语法"><a href="#一，lambda基本语法" class="headerlink" title="一，lambda基本语法"></a>一，lambda基本语法</h2><p>其实lambda表达式跟原来写一个方法思路是很相似的，只是，lambda表达式可以使我们原来的方法简单化编码，更加清晰明了</p>
<p>基本结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(方法参数) -&gt; 方法体</span></span><br><span class="line">(args)-&gt;body</span><br></pre></td></tr></table></figure>

<p>常见的基本写法可以有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1. 参数类型可推导时，不需要指定类型，如 (a) -&gt; System.out.println(a)</span></span><br><span class="line"><span class="comment">* 2. 当只有一个参数且类型可推导时，不强制写 (), 如 a -&gt; System.out.println(a)</span></span><br><span class="line"><span class="comment">* 3. 参数指定类型时，必须有括号，如 (int a) -&gt; System.out.println(a)</span></span><br><span class="line"><span class="comment">* 4. 参数可以为空，如 () -&gt; System.out.println(“hello”)</span></span><br><span class="line"><span class="comment">* 5. body 需要用 &#123;&#125; 包含语句，当只有一条语句时 &#123;&#125; 可省略</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">(a) -&gt; a * a</span><br><span class="line">(<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; a + b</span><br><span class="line">(a, b) -&gt; &#123;<span class="keyword">return</span> a - b;&#125;</span><br><span class="line">() -&gt; System.out.println(Thread.currentThread().getId())</span><br></pre></td></tr></table></figure>

<h2 id="二，函数式接口"><a href="#二，函数式接口" class="headerlink" title="二，函数式接口"></a>二，函数式接口</h2><p>java中的lambda表达式是以函数式接口为基础的</p>
<p><strong>什么是函数式接口？</strong></p>
<p>函数式接口（FunctionalInterface)就是只有一个方法的接口，这类接口的目的就是进行单一操作，这些函数式接口一般都带有注解@FunctionalInterface </p>
<p>EG:</p>
<p>平时我们创建线程使用的Runnable接口就是一个函数式接口</p>
<p>原始创建线程的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"没有使用lambda表达式"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们使用lambda表达式创建线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(()-&gt;System.out.println(<span class="string">"使用lambda表达式创建线程"</span>)).start();</span><br></pre></td></tr></table></figure>

<p>是不是更加简单清晰了</p>
<p>注意看Thread的参数，原来我们需要传一个Runable实现类或者以匿名内部类的方法编写，但是现在，我们可以使用lambda表达式来作为函数参数，由此可见，Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）</p>
<p>之前我们写过一个按jsonArray某字段进行排序的一个方法，但是这个方法中的比较器是使用传统方式编写的，现在我们来用lambda试着简化一下：</p>
<p>原函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对json数组排序，</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> jsonArr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sortKey 排序关键字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> is_desc is_desc-false升序列  is_desc-true降序 (排序字段为字符串)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">jsonArraySort</span><span class="params">(JSONArray jsonArr, String sortKey, <span class="keyword">boolean</span> is_desc)</span> </span>&#123;</span><br><span class="line">    JSONArray sortedJsonArray = <span class="keyword">new</span> JSONArray();</span><br><span class="line">    List&lt;JSONObject&gt; jsonValues = <span class="keyword">new</span> ArrayList&lt;JSONObject&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jsonArr.size(); i++) &#123;</span><br><span class="line">        jsonValues.add(JSONObject.parseObject(String.valueOf(jsonArr.getJSONObject(i))));</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(jsonValues, <span class="keyword">new</span> Comparator&lt;JSONObject&gt;() &#123;</span><br><span class="line">        <span class="keyword">private</span>  <span class="keyword">final</span> String KEY_NAME = sortKey;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(JSONObject a, JSONObject b)</span> </span>&#123;</span><br><span class="line">            String valA = <span class="keyword">new</span> String();</span><br><span class="line">            String valB = <span class="keyword">new</span> String();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                valA = a.getString(KEY_NAME);</span><br><span class="line">                valB = b.getString(KEY_NAME);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JSONException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is_desc)&#123;</span><br><span class="line">                <span class="keyword">return</span> -valA.compareTo(valB);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -valB.compareTo(valA);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jsonArr.size(); i++) &#123;</span><br><span class="line">        sortedJsonArray.add(jsonValues.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedJsonArray.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用lambda表达式简化代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对json数组排序，</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> jsonArr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sortKey 排序关键字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> is_desc is_desc-false升序列  is_desc-true降序 (排序字段为字符串)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">jsonArraySort</span><span class="params">(JSONArray jsonArr, String sortKey, <span class="keyword">boolean</span> is_desc)</span> </span>&#123;</span><br><span class="line">    JSONArray sortedJsonArray = <span class="keyword">new</span> JSONArray();</span><br><span class="line">    List&lt;JSONObject&gt; jsonValues = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    jsonArr.forEach(a-&gt;jsonValues.add(JSONObject.parseObject(String.valueOf(a))));</span><br><span class="line">    Collections.sort(jsonValues,(JSONObject a, JSONObject b)-&gt;&#123;</span><br><span class="line">        <span class="keyword">final</span> String KEY_NAME = sortKey;</span><br><span class="line">        String valA = a.getString(KEY_NAME);</span><br><span class="line">        String valB = b.getString(KEY_NAME);</span><br><span class="line">        <span class="keyword">if</span>(is_desc)&#123;</span><br><span class="line">            <span class="keyword">return</span> -valA.compareTo(valB);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> valA.compareTo(valB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    jsonArr.forEach(a -&gt; sortedJsonArray.add(a));</span><br><span class="line">    <span class="keyword">return</span> sortedJsonArray.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK中的函数式接口<br>为了现有的类库能够直接使用 Lambda 表达式，Java 8 以前存在一些接口已经被标注为函数式接口的：</p>
<ul>
<li>java.lang.Runnable</li>
<li>java.util.Comparator</li>
<li>java.util.concurrent.Callable</li>
<li>java.io.FileFilter</li>
<li>java.security.PrivilegedAction</li>
<li>java.beans.PropertyChangeListener</li>
</ul>
<p>Java 8 中更是新增加了一个包 java.util.function，带来了常用的函数式接口：</p>
<ul>
<li>Function&lt;T, R&gt; - 函数：输入 T 输出 R</li>
<li>BiFunction&lt;T, U, R&gt; - 函数：输入 T 和 U 输出 R 对象</li>
<li>Predicate<t> - 断言/判断：输入 T 输出 boolean</t></li>
<li>BiPredicate&lt;T, U&gt; - 断言/判断：输入 T 和 U 输出 boolean</li>
<li>Supplier<t> - 生产者：无输入，输出 T</t></li>
<li>Consumer<t> - 消费者：输入 T，无输出</t></li>
<li>BiConsumer&lt;T, U&gt; - 消费者：输入 T 和 U 无输出</li>
<li>UnaryOperator<t> - 单元运算：输入 T 输出 T</t></li>
<li>BinaryOperator<t> - 二元运算：输入 T 和 T 输出 T</t></li>
</ul>
<p>另外还对基本类型的处理增加了更加具体的函数是接口，包括：BooleanSupplier, DoubleBinaryOperator, DoubleConsumer, DoubleFunction<r>, DoublePredicate, DoubleSupplier, DoubleToIntFunction, DoubleToLongFunction, DoubleUnaryOperator, IntBinaryOperator, IntConsumer, IntFunction<r>, IntPredicate, IntSupplier, IntToDoubleFunction, IntToLongFunction, IntUnaryOperator, LongBinaryOperator, LongConsumer, LongFunction<r>, LongPredicate, LongSupplier, LongToDoubleFunction, LongToIntFunction, LongUnaryOperator, ToDoubleBiFunction&lt;T, U&gt;, ToDoubleFunction<t>, ToIntBiFunction&lt;T, U&gt;, ToIntFunction<t>, ToLongBiFunction&lt;T, U&gt;, ToLongFunction<t> 。结合上面的函数式接口，对这些基本类型的函数式接口通过类名就能一眼看出接口的作用</t></t></t></r></r></r></p>
<p>纵观上述函数式接口，其实可以分为四大类：</p>
<ul>
<li>消费型（有参数，无返回值）</li>
<li>生成型（无参数，有返回值）</li>
<li>一般型（参数，返回值都有）</li>
<li>断言型（输出布尔型）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kevin091827.github.io/2019/08/06/java8新特性-lambda表达式/" data-id="cjz54ryes0004kwu3mcdhw157"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java基础/">java基础</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-jwt认证实践" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/08/06/jwt认证实践/">jwt认证实践</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/08/06/jwt认证实践/" class="article-date">
  <time datetime="2019-08-06T06:54:08.000Z" itemprop="datePublished">2019-08-06</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <p>在进行前后端项目开发时，身份认证是一个很重要的问题。</p>
<p>在身份认证这一块上，我们可以使用JWT来进行验证</p>
<h1 id="一，JWT简述"><a href="#一，JWT简述" class="headerlink" title="一，JWT简述"></a>一，JWT简述</h1><p>JWT(Json Web Token)是一种为了在网络应用环境之间传递声明而基于json的开放标准，JWT声明一般被采用在身份提供者和服务器提供者间传递被认证的身份信息，以便从资源服务器获取资源</p>
<p>JWT一般用于用户登录上，身份认证这种场景下，一旦用户登录完成，在接下来的每个涉及用户权限的请求中都包含JWT，可以对用户身份，路由，服务和资源的访问权限进行验证</p>
<p>举一个例子，假如一个电商网站，在用户登录以后，需要验证用户的地方其实有很多，比如购物车，订单页，个人中心等等，访问这些页面正常的逻辑是先验证用户权限和登录状态，如果验证通过，则进入访问的页面，否则重定向到登录页。</p>
<h1 id="二，JWT对比session或cookie"><a href="#二，JWT对比session或cookie" class="headerlink" title="二，JWT对比session或cookie"></a>二，JWT对比session或cookie</h1><p>在JWT之前，这样的身份认证大多数都是通过session和cookie去实现的</p>
<h2 id="1-用户身份认证cookie-session实现"><a href="#1-用户身份认证cookie-session实现" class="headerlink" title="1.用户身份认证cookie session实现"></a>1.用户身份认证cookie session实现</h2><p><img src="https://img-blog.csdn.net/2018091121224432?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E3NTQ4OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<p>浏览器第一次请求服务器时，服务器会为浏览器的这次会话（session）生成一个索引为session_id的会话数据存入服务器的后端数据库，然后在cookie中存入session_id封装在响应信息中，返回给浏览器保存在本地主机的cookie文件（追加写入），第二次请求时带上cookie信息去请求服务器，服务器解析出cookie中的session_id去查询后端数据库返回相应信息</p>
<p><strong>缺陷</strong></p>
<ol>
<li><p>服务器需要保存session数据，数据量增大，服务器性能会受到很大的影响，内存开销大</p>
</li>
<li><p>服务器session不能共享，严重的限制了服务器扩展能力， 比如说我用两个机器组成了一个集群， 小F通过机器A登录了系统，  那session id会保存在机器A上，  假设小F的下一次请求被转发到机器B怎么办？  机器B可没有小F的 session id啊。只能进行session复制转移到另一台机器</p>
<p> <img src="https://images2018.cnblogs.com/blog/1350514/201805/1350514-20180504122814029-1201707523.png" alt></p>
</li>
<li><p>基于上述解决session不能共享的问题，还可以使用redis或者Memcached中作为session共享服务器，但是，如果共享服务器挂掉，就会影响到所有服务器的会话管理</p>
<p> <img src="https://images2018.cnblogs.com/blog/1350514/201805/1350514-20180504123036062-1920411426.png" alt></p>
</li>
<li><p>使用本机cookie保存也会出现数据泄露或者遭到踹改的问题</p>
</li>
</ol>
<h2 id="2-用户身份认证JWT实现"><a href="#2-用户身份认证JWT实现" class="headerlink" title="2.用户身份认证JWT实现"></a>2.用户身份认证JWT实现</h2><h3 id="1-JWT结构"><a href="#1-JWT结构" class="headerlink" title="1.JWT结构"></a>1.JWT结构</h3><p>JWT生成的token由三部分组成，用 . 隔开</p>
<ul>
<li><p><strong>header</strong></p>
<p>  header主要包括：</p>
<ul>
<li><p>token类型</p>
</li>
<li><p>所使用的加密算法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    typ: "jwt", </span><br><span class="line">    alg: "HS256"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>payload</strong></p>
<p>  payload主要是用来存放有效信息，有效信息中被分为标准中注册的声明，公共的声明和私有声明</p>
<p>  <strong>下面是标准中注册的声明，建议但不强制使用。</strong></p>
<ul>
<li><p>iss：jwt 签发者；</p>
</li>
<li><p>sub：jwt 所面向的用户；</p>
</li>
<li><p>aud：接收 jwt 的一方；</p>
</li>
<li><p>exp：jwt 的过期时间，这个过期时间必须要大于签发时间，这是一个秒数；</p>
</li>
<li><p>nbf：定义在什么时间之前，该 jwt 都是不可用的；</p>
</li>
<li><p>iat：jwt 的签发时间。</p>
<p>上面的标准中注册的声明中常用的有 exp 和 nbf。</p>
</li>
</ul>
<p>  <strong>公共声明</strong></p>
<p>  公共声明可以添加任何信息，一般添加用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，该部分在客户端可以解密获得</p>
<p>  <strong>私有声明</strong></p>
<p>  私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为 base64 是对称解密的，意味着该部分信息可以归类为明文信息。</p>
</li>
<li><p><strong>signature 签名</strong></p>
<p>  签名这一部分是指将header或payload通过秘钥进行加密后生成，秘钥存储在服务端，不会发送给任何人，所以jwt的运输方式很安全</p>
<p>  最后将三部分使用 . 连接成字符串，就是要返回给浏览器的 token 浏览器一般会将这个 token 存储在 localStorge 以备其他需要验证用户的请求使用。</p>
</li>
</ul>
<h3 id="2-实现身份认证"><a href="#2-实现身份认证" class="headerlink" title="2.实现身份认证"></a>2.实现身份认证</h3><p><img src="https://img-blog.csdnimg.cn/20190807193552928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>实现：</p>
<p>controller</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> LoginService loginService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> AjaxResult <span class="title">login</span><span class="params">(@RequestParam(<span class="string">"userName"</span>)</span>String userName,</span></span><br><span class="line"><span class="function">                        @<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span>String password)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loginService.login(userName, password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServiceImpl</span> <span class="keyword">implements</span> <span class="title">LoginService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginMapper loginMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AjaxResult <span class="title">login</span><span class="params">(String userName, String password)</span> </span>&#123;</span><br><span class="line">        Guest guest =  loginMapper.selectFromTbGuest(userName, password);</span><br><span class="line">        <span class="comment">//校验</span></span><br><span class="line">        <span class="keyword">if</span>(guest != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//校验成功</span></span><br><span class="line">            <span class="comment">//信息封装返回给前端</span></span><br><span class="line">            Map resultMap = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">            <span class="comment">//登录成功</span></span><br><span class="line">            String token = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//生成token</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//加密用户名和密码(仅为参考，一般不存储用户的隐私敏感信息)</span></span><br><span class="line">                String key = Base64.getEncoder().encodeToString((guest.getUserName()+<span class="string">","</span>+guest.getPassword()).getBytes());</span><br><span class="line">                Map claims = <span class="keyword">new</span> HashMap();</span><br><span class="line">                claims.put(<span class="string">"key"</span>,key);</span><br><span class="line">                token = JwtUtils.createJwt(claims,<span class="string">"admin"</span>,<span class="number">720000</span>);</span><br><span class="line">                resultMap.put(<span class="string">"token"</span>,token);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                log.error(<span class="string">"生成token失败"</span>+e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            resultMap.put(<span class="string">"msg"</span>,<span class="string">"登录成功"</span>);</span><br><span class="line">            <span class="comment">//封装返回信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AjaxResult().ok(resultMap);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AjaxResult().error(<span class="string">"登录失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jwt工具类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String JWT_SECRET = <span class="string">"123456789abcdefg"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 签发jwt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> claims</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject   主题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ttlMillis 存活时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createJwt</span><span class="params">(Map claims, String subject, <span class="keyword">long</span> ttlMillis)</span></span>&#123;</span><br><span class="line">        <span class="comment">//jwt头部中的签名算法，默认是Hsha256</span></span><br><span class="line">        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;</span><br><span class="line">        <span class="comment">//jwt签发时间</span></span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        Date nowTime = <span class="keyword">new</span> Date(now);</span><br><span class="line">        <span class="comment">//生成签名时使用的秘钥</span></span><br><span class="line">        SecretKey secretKey = generalKey();</span><br><span class="line">        <span class="comment">//构造payload</span></span><br><span class="line">        JwtBuilder jwtBuilder = Jwts.builder()</span><br><span class="line">                .setClaims(claims)</span><br><span class="line">                .setIssuedAt(nowTime)</span><br><span class="line">                .setSubject(subject)</span><br><span class="line">                .signWith(signatureAlgorithm,secretKey);</span><br><span class="line">        <span class="keyword">if</span>(ttlMillis &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//设置过期时间</span></span><br><span class="line">            Date expireTime = <span class="keyword">new</span> Date(now + ttlMillis);</span><br><span class="line">            jwtBuilder.setExpiration(expireTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">return</span> jwtBuilder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 签名秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SecretKey <span class="title">generalKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = Base64.decodeBase64(JWT_SECRET);</span><br><span class="line">        <span class="comment">//AES构造指定的秘钥</span></span><br><span class="line">        SecretKey secretKey = <span class="keyword">new</span> SecretKeySpec(data,<span class="number">0</span>,data.length,<span class="string">"AES"</span>);</span><br><span class="line">        <span class="keyword">return</span> secretKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析jwt获取claims数据对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title">parseJWT</span><span class="params">(String jwt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        SecretKey secretKey = generalKey();</span><br><span class="line">        Claims claims = Jwts.parser()</span><br><span class="line">                .setSigningKey(secretKey)</span><br><span class="line">                .parseClaimsJws(jwt)</span><br><span class="line">                .getBody();</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拦截器设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginMapper loginMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 预处理方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 允许跨域</span></span><br><span class="line">        response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">        String token = request.getHeader(<span class="string">"authorization"</span>);</span><br><span class="line">        <span class="comment">//服务器内置的token，用于测试接口</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"testToken"</span>.equals(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.----------- 解析jwt信息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断token是否为null，使用Optional防止出现空指针异常（optional可以接受null值）</span></span><br><span class="line">        Optional.ofNullable(token)</span><br><span class="line">                .map(n -&gt; &#123;</span><br><span class="line">                    <span class="comment">//判断token是否过期，过期则抛出异常</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        log.info(<span class="string">"-----&gt;"</span>+n);</span><br><span class="line">                        <span class="keyword">return</span> JwtUtils.parseJWT(n);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        log.warn(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;token不存在!，重新授权登录！&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>);</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"token不存在!，重新授权登录！"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.------------- 数据库交互</span></span><br><span class="line"></span><br><span class="line">        String subject = JwtUtils.parseJWT(token).getSubject();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"admin"</span>.equals(subject))&#123;</span><br><span class="line">            <span class="comment">//管理员</span></span><br><span class="line">            <span class="comment">//取出claims中的用户标识</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = Base64.getDecoder().decode(String.valueOf(JwtUtils.parseJWT(token).get(<span class="string">"key"</span>)));</span><br><span class="line">            <span class="comment">//byte[]转String</span></span><br><span class="line">            String userInfo = <span class="keyword">new</span> String(bytes);</span><br><span class="line">            <span class="comment">//分割userInfo，获取userName和password</span></span><br><span class="line">            String[] strs = userInfo.split(<span class="string">","</span>);</span><br><span class="line">            <span class="comment">//校验用户是否存在数据库</span></span><br><span class="line">            Guest guest = loginMapper.selectFromTbGuest(strs[<span class="number">0</span>],strs[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">return</span> guest != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p><img src="https://img-blog.csdnimg.cn/20190807195656662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>使用token请求资源api</p>
<p><img src="https://img-blog.csdnimg.cn/20190807195806689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>总结：</p>
<p>JWT本身没啥难度，但是安全整体是一件比较复杂的事情，JWT只不过负责提供了一种基于token的身份验证机制，但是对于我们的用户权限，对于相应用户权限的api划分，资源的权限划分等，都不是JWT负责的，也就是说，请求验证完成，是否有权限请求对应的内容还是由用户权限决定</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kevin091827.github.io/2019/08/06/jwt认证实践/" data-id="cjz54ryh6001skwu3lbz7pvwz"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/项目总结/">项目总结</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-avl树" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/08/03/avl树/">avl树</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/08/03/avl树/" class="article-date">
  <time datetime="2019-08-03T14:39:14.000Z" itemprop="datePublished">2019-08-03</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h2 id="AVL：完全平衡的二叉查找树"><a href="#AVL：完全平衡的二叉查找树" class="headerlink" title="AVL：完全平衡的二叉查找树"></a>AVL：完全平衡的二叉查找树</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>AVL树是带有平衡条件的二叉查找树</p>
<p>二叉查找树可以表示动态的数据集合，对于给定的数据集合，在建立一棵二叉查找树时，二叉查找树的结构形态和关键字的插入顺序有关，如果全部或者部分的按照关键字的递增或者递减顺序插入二叉查找树的节点，则会导致所建立的二叉查找树全部或者局部退化成单支结构，最坏情况下，二叉查找树可能完全偏斜，倘若树的高度为n，则平均和最坏情况下的查找时间都是O(N) ，而最好情况是要查找的节点应该尽可能接近根节点，所以，平衡树的出现就是为了希望二叉查找树始终处于良好的结构形态</p>
<p><img src="https://segmentfault.com/img/remote/1460000006769983" alt></p>
<p>AVL平衡树：是一种在高度上相对平衡的二叉查找树，其平均和最坏情况下的查找时间都是O(logN),同时插入和删除也会保持O(logN)，删除和插入之后的树仍然保持平衡</p>
<p>平衡条件：</p>
<p>左右子树的高度差的绝对值不超过1</p>
<h3 id="2-节点高度"><a href="#2-节点高度" class="headerlink" title="2.节点高度"></a>2.节点高度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 求当前节点高度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hight</span><span class="params">(AvlNode k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k == <span class="keyword">null</span> ? -<span class="number">1</span> : k.hight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-树旋转"><a href="#3-树旋转" class="headerlink" title="3.树旋转"></a>3.树旋转</h3><p>在对二叉查找树进行插入删除之后如何保持平衡呢？答案就是通过树的旋转</p>
<p>树的旋转分为两种：</p>
<ul>
<li>左旋</li>
<li>右旋</li>
</ul>
<p><strong>左旋掕右左挂右，右旋掕左右挂左</strong></p>
<h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><p>当新插入的节点是右子树的右子节点时，需要通过左旋来保持此部分子树继续处于平衡状态</p>
<p><img src="https://segmentfault.com/img/remote/1460000006123258" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单旋 --- 左旋</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 适用情况：</span></span><br><span class="line"><span class="comment"> *          1.新插入节点是右子树的右子节点</span></span><br><span class="line"><span class="comment"> *          2.右子树的右子节点高度 &gt;= 右子树左子节点的高度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AvlNode <span class="title">leftBalance</span><span class="params">(AvlNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//左旋掕右左挂右</span></span><br><span class="line">    AvlNode node = root.right;</span><br><span class="line">    root.right = node.left;</span><br><span class="line">    node.left = root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//高度重置</span></span><br><span class="line">    root.hight = Math.max(hight(root.left),hight(root.right))+<span class="number">1</span>;</span><br><span class="line">    node.hight = Math.max(hight(node.right),hight(root))+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><p>当新插入的节点是左子树的左子节点时，需要通过右旋来保持此部分子树继续保持平衡状态</p>
<p><img src="https://segmentfault.com/img/remote/1460000006123262" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单旋 --- 右旋</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用情况：</span></span><br><span class="line"><span class="comment"> *          1.新插入节点是左子树的左子节点</span></span><br><span class="line"><span class="comment"> *          2.左子树的左子节点的高度 &gt;= 左子树右子节点的高度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AvlNode <span class="title">rightBalance</span><span class="params">(AvlNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//右旋掕左右挂左</span></span><br><span class="line">    AvlNode node = root.left;</span><br><span class="line">    root.left = node.right;</span><br><span class="line">    node.right = root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//高度重置</span></span><br><span class="line">    root.hight = Math.max(hight(root.left),hight(root.right))+<span class="number">1</span>;</span><br><span class="line">    node.hight = Math.max(hight(node.left),hight(root))+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双旋"><a href="#双旋" class="headerlink" title="双旋"></a>双旋</h4><blockquote>
<p>在某些情况下，我们需要旋转两次来保持树结构的平衡</p>
</blockquote>
<p><strong>先左旋再右旋</strong></p>
<p>当新插入的节点是左子树的右子节点时，需要通过先左旋在右旋来保持此结构的平衡</p>
<p><img src="https://segmentfault.com/img/remote/1460000006123272" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双旋 --- 先左旋后右旋</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 适用情况：</span></span><br><span class="line"><span class="comment"> *         1.新插入节点是左子树的右子节点</span></span><br><span class="line"><span class="comment"> *         2.左子树左子节点高度 &lt;= 左子树右子节点高度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AvlNode <span class="title">doubleLeftThenRight</span><span class="params">(AvlNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//左旋</span></span><br><span class="line">    root.left = leftBalance(root.left);</span><br><span class="line">    <span class="comment">//右旋</span></span><br><span class="line">    <span class="keyword">return</span> rightBalance(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>先右旋在左旋</strong><br>当新插入的节点是右子树的左子节点时，需要通过先右旋在左旋来保持树的平衡</p>
<p><img src="https://segmentfault.com/img/remote/1460000006123285" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双旋 --- 先右旋后左旋</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 适用情况：</span></span><br><span class="line"><span class="comment"> *          1.新插入节点是右子树的左子节点</span></span><br><span class="line"><span class="comment"> *          2.右子树的左子节点高度 &gt;= 右子树右子节点高度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AvlNode <span class="title">doubleRightThenLeft</span><span class="params">(AvlNode root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//右旋</span></span><br><span class="line">    root.right = rightBalance(root.right);</span><br><span class="line">    <span class="comment">//左旋</span></span><br><span class="line">    <span class="keyword">return</span> leftBalance(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依靠左旋和右旋来保持树的平和结构</p>
<p><strong>平衡树结构</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 平衡树结构</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AvlNode <span class="title">balance</span><span class="params">(AvlNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新节点插入的左子树</span></span><br><span class="line">    <span class="keyword">if</span> (hight(root.left) - hight(root.right) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//新节点插入的左子树的左子节点</span></span><br><span class="line">        <span class="keyword">if</span>(hight(root.left.left) &gt;= hight(root.left.right))&#123;</span><br><span class="line">            <span class="comment">//右旋</span></span><br><span class="line">            root = rightBalance(root);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//新节点插入的是左子树的右子节点</span></span><br><span class="line">            <span class="comment">//先左旋后右旋</span></span><br><span class="line">            root = doubleLeftThenRight(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新节点插入的右子树</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span>(hight(root.right) - hight(root.left) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//新节点插入的是右子树的右子节点</span></span><br><span class="line">        <span class="keyword">if</span>(hight(root.right.right) &gt;= hight(root.right.left))&#123;</span><br><span class="line">            <span class="comment">//左旋</span></span><br><span class="line">            root = leftBalance(root);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//新节点插入的右子树的左子节点</span></span><br><span class="line">            <span class="comment">//先右旋后左旋</span></span><br><span class="line">            root = doubleRightThenLeft(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//高度重置</span></span><br><span class="line">    root.hight = Math.max(hight(root.left),hight(root.right))+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-构造平衡树"><a href="#4-构造平衡树" class="headerlink" title="4.构造平衡树"></a>4.构造平衡树</h3><p>构造平衡树的方法和构造二叉查找树一样，只是多了平衡结构建立而已</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建平衡树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AvlNode <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x,AvlNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AvlNode(<span class="keyword">null</span>,<span class="keyword">null</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; root.val)&#123;</span><br><span class="line">        root.right = insert(x,root.right);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root.val)&#123;</span><br><span class="line">        root.left = insert(x,root.left);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        root.val = x;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> balance(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-删除平衡树中指定节点"><a href="#5-删除平衡树中指定节点" class="headerlink" title="5.删除平衡树中指定节点"></a>5.删除平衡树中指定节点</h3><p>删除节点和二叉查找树一致，但是删除后，需要恢复平衡结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除平衡树中的指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AvlNode <span class="title">remove</span><span class="params">(<span class="keyword">int</span> x,AvlNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//寻找指定节点</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt; root.val)&#123;</span><br><span class="line">        root.right = remove(x,root.right);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root.val)&#123;</span><br><span class="line">        root.left = remove(x,root.left);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//找到了指定节点</span></span><br><span class="line">        <span class="comment">//判断是否存在子节点，以及是单个子节点还是两个子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//左右子节点都存在</span></span><br><span class="line">            <span class="comment">//找出右子树中的最小值</span></span><br><span class="line">            root.val = findMin(root.right).val;</span><br><span class="line">            <span class="comment">//转成一个子节点的情况</span></span><br><span class="line">            root.right = remove(root.val,root.right);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//存在一个子节点,不空则覆盖</span></span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//叶节点情况</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重新平衡</span></span><br><span class="line">    <span class="keyword">return</span> balance(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://kevin091827.github.io/2019/08/03/avl树/" data-id="cjz54ryel0001kwu3ms1dvezd"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构和算法/">数据结构和算法</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-tcp-and-udp" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/08/02/tcp-and-udp/">tcp and udp </a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/08/02/tcp-and-udp/" class="article-date">
  <time datetime="2019-08-02T15:36:33.000Z" itemprop="datePublished">2019-08-02</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h1 id="一，运输层协议概述"><a href="#一，运输层协议概述" class="headerlink" title="一，运输层协议概述"></a>一，运输层协议概述</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>从通信和信息处理的角度看，运输层向他上面的应用层提供通信服务，是面向通信的最高层，也是用户功能中的最低层</p>
<p>两台主机进行通信，就是两台主机中的应用进程进行互相通信，网络层的ip协议负责将分组送到目的主机，运输层则负责将分组交付到主机中的指定进程中</p>
<p>所以</p>
<pre><code>网络层：主机到主机的通信
运输层：主机中的进程到另一台主机中的进程间的通信</code></pre><h2 id="2-主要工作"><a href="#2-主要工作" class="headerlink" title="2.主要工作"></a>2.主要工作</h2><ol>
<li>提供进程间的端到端通信</li>
<li>对报文进行差错检测</li>
<li>分用复用</li>
</ol>
<h2 id="3-运输层两大协议"><a href="#3-运输层两大协议" class="headerlink" title="3.运输层两大协议"></a>3.运输层两大协议</h2><h3 id="1-udp协议"><a href="#1-udp协议" class="headerlink" title="1.udp协议"></a>1.udp协议</h3><p>udp是面向无连接的的运输层协议，在传输数据之前无需建立连接，接收方接收到udp用户数据报后也无需给发送方发出确认报文，udp提供的是不可靠的交付，但是其优点就是简单，高效</p>
<p><strong>特点：</strong></p>
<ol>
<li><p>udp只是在ip协议的基础上添加了分用复用，差错检测和其他少许功能</p>
</li>
<li><p>面向无连接的服务，发送数据前无需建立连接，所以，减少了连接开销和发送之前的时延</p>
</li>
<li><p>udp提供不可靠的交付，交付完成后没有确认报文，因此主机无需维持复杂的连接状态表</p>
</li>
<li><p>udp是面向报文的协议，udp对接收的报文，既不合并也不拆分，而是保留报文的边界，在添加首部后就交往网络ip层，一次发送一个报文，所以，应用程序必须选择合适大小的报文，如果报文太长，交给ip层后需要对其进行分片发送，降低了ip层的效率，如果报文太短，则首部显得过长，也会降低效率</p>
</li>
<li><p>udp没有拥塞控制</p>
</li>
<li><p>udp支持一对一，一对多，多对一，多对多的通信</p>
</li>
<li><p>udp首部开销小，只有4个字段,源端口，目的端口，udp用户数据报长度，检验和四个字段，8个字节</p>
</li>
</ol>
<p>总体来看,UDP还是比较简单的.它适用于那些无须关心数据是否准确到达的服务, 如视频电话, 局域网游戏等.</p>
<p><strong>udp的分用和复用</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190803145153490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-tcp协议"><a href="#2-tcp协议" class="headerlink" title="2.tcp协议"></a>2.tcp协议</h3><blockquote>
<p>tcp是tcp/ip体系中非常复杂的一个协议</p>
</blockquote>
<h4 id="1-特点"><a href="#1-特点" class="headerlink" title="1.特点"></a>1.特点</h4><ul>
<li><p>tcp是面向连接的运输层协议，在传输数据前需要建立连接，传输完成需要断开连接</p>
</li>
<li><p>tcp只提供一对一的通信服务</p>
</li>
<li><p>tcp提供可靠交付，通过tcp传输的数据，无差错，不丢失，不重复且按序到达</p>
</li>
<li><p>tcp提供全双工通信，双方可以在任何时候发送数据，tcp连接两端设有发送缓存和接收缓存，用来临时存放双向通信的数据，在发送时，应用程序把要发送的数据存入发送缓存就可以做自己的事情，tcp会在适合时间发送出去，接收方把接收到的数据放入接收缓存，应用程序在适合时间读取接收缓存中的数据</p>
</li>
<li><p>面向字节流.<br>流是指流入到进程或从进程流出的字节序列.<br>面向字节流的含义是:虽然应用程序和TCP交互的是大小不等的数据块,但TCP把这些数据看成无结构的字节流.TCP只保证发送方发出的字节流和接收方接到的字节流相同.</p>
</li>
</ul>
<h4 id="2-tcp连接管理"><a href="#2-tcp连接管理" class="headerlink" title="2.tcp连接管理"></a>2.tcp连接管理</h4><blockquote>
<p>tcp的连接管理就是我们平时说的很多的一句话，三次握手，四次挥手</p>
</blockquote>
<p>tcp在建立连接过程中要解决的问题：</p>
<ul>
<li><p>要是tcp双方能够确知对方的存在</p>
</li>
<li><p>要允许tcp双方协商一些参数</p>
</li>
<li><p>能够对运输实体资源进行分配</p>
</li>
</ul>
<p><strong>tcp连接过程（三报文握手）</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190803153718705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>为什么发送方最后还要发送一次确认呢？</p>
<p>假定这样一种情况，a发出第一个连接请求报文段在发送过程中长时间滞留，a误以为报文段丢失就开启重传机制重传该报文，但是实际上，该报文并没有丢失，还是正确发送给a，这样a就会收到两个确认报文，如果没有最后一步的确认？只要接收方发送确认，就会建立新的连接</p>
<p><strong>tcp释放连接过程（四报文挥手）</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20190803154631346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>为何要等待2MSL，客户端才能关闭连接</p>
<p>保证客户端发出的报文D能够到达服务器。在报文D丢失的情况下，服务器未收到客户端的响应，所以会触发TCP的超时重传，而客户端可以在2MSL时间内收到重传的报文，并对之响应且重新启动2MSL计时器。最终，该连接可以正常关闭。<br>防止失效的连接请求报文出现。可以保证在创建该TCP连接中发出的报文都在网络中消失。</p>
<h4 id="3-tcp报文格式"><a href="#3-tcp报文格式" class="headerlink" title="3.tcp报文格式"></a>3.tcp报文格式</h4><p><img src="https://user-gold-cdn.xitu.io/2018/1/1/160b0837721690b4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>从上图可以看到, TCP的首部是由固定的20字节加上后面的选项部分(4n字节,n 需要为整数).</p>
<ul>
<li><p>目的端口和源端口, 各占2字节.基于端口复用和分用(在上篇提到过这个概念).</p>
</li>
<li><p>序号, 占4字节. 范围是[0, 2^32-1].序号达到最大值后, 又回到0从新开始.因为TCP是面向字节流的, 在TCP中传送的每一个字节都按序编号. 整个要传送的字节流的起始序号在连接建立时确定.首部中的该字段指的是本报文段所发送的数据的第一个字节的序号.例如: 一个报文段的序号为301, 而携带数据100字节; 可以确定的是,本报文段数据的第一个字节序号为301, 最后一个字节的序号为400, 下一个报文段的序号应该是401.</p>
</li>
<li><p>确认号, 占4字节.表示期望收到对方下一个报文段的数据第一个字节的序号.例如,B正确收到A发过来的一个报文段,其序号值为501,而数据长度是200字节(也就是说该报文段的数据字节序号从501到700).这表明B正确收到了A发送的到序号700为止的数据, 因此B期望收到A的下一个数据的序号是701, 于是B将发给A的确认报文的确认号置为701.请记住,确认号为N,表明序号为N-1的所有数据都以正确收到.</p>
</li>
<li><p>数据偏移, 占4bit. 它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远(单位4字节).其实它指出了TCP报文首部的长度是多少.由于TCP报文首部还有不确定的选项部分,该字段的存在是必要的.最大偏移为15 * 4字节=60字节(也确定了TCP首部的最大字节数), 去掉首部固定的20字节, 即选项部分最大为40字节.<br>保留, 占6bit. 暂未使用,目前置为0.</p>
</li>
<li><p>紧急URG(URGent), 占1bit. 当URG=1时,表明后面的紧急指针有效.它表明该报文中有紧急数据,需要优先传送.</p>
</li>
<li><p>确认ACK(ACKnowledgment), 占1bit.当ACK=1时,确认号字段才有效.</p>
</li>
<li><p>推送PSH(Push),占1bit. 当两个应用程序进行交互式通信时, 在一端的应用进程希望在键入一个命令后立即的到对方的响应.这种情况下,TCP可以将PSH置为1,并立即创建一个报文发送出去,接收方在收到PUS=1的报文后,尽快的向上交付.</p>
</li>
<li><p>复位RST(ReSet), 占1bit. 当RST=1时,表明TCP连接出现严重错误,必须释放连接,重新建立.还可以使用RST=1来拒绝一个非法的报文段或拒绝打开一个连接.</p>
</li>
<li><p>同步SYN(SYNChronization), 占1bit. 在建立连接时使用同步序号.当SYN=1而ACK=0时表明这是一个请求建立连接的报文. 若对方同意建立连接,则响应报文中SYN和ACK都应该是1.可以发现,当SYN=1时说明该报文是用来建立连接的(请求建立连接报文,或同意建立连接报文).</p>
</li>
<li><p>终止FIN, 占1bit.用来释放连接,当FIN=1时,表明此报文的发送方数据已经发送完毕,要求释放连接.</p>
</li>
<li><p>窗口, 占2字节.值的范围是[0, 2^16-1]之间的整数.指出了接收方目前可以接受数据的大小, 发送方在发送数据时必须考虑到这点.例如,A(作为接收方)发出了一个确认报文,确认号为701(这表明前700个编号数据都正确接收),窗口字段为1000. 这表明A的接收缓存空间还可以接收从编号701到1700的1000字节数据.总之,窗口明确指出了允许发送方发送的数据数量.</p>
</li>
<li><p>校验和, 占2字节. 包含首部和数据两部分的校验.这里不对校验的方法做深入讨论.<br>紧急指针, 占2字节.仅在URG=1才有效.它指出紧急数据的字节数量(紧急数据在该报文的数据部分最前方).即使窗口为0,也可以发送紧急数据.<br>选项, 长度可变,最长40字节.</p>
</li>
</ul>
<h4 id="4-tcp可靠传输实现"><a href="#4-tcp可靠传输实现" class="headerlink" title="4.tcp可靠传输实现"></a>4.tcp可靠传输实现</h4><p>tcp可靠传输的实现主要依靠：</p>
<ul>
<li>滑动窗口协议</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
<h5 id="1-滑动窗口协议"><a href="#1-滑动窗口协议" class="headerlink" title="1.滑动窗口协议"></a>1.滑动窗口协议</h5><p>以字节为单位的滑动窗口，接收方和发送方都维护一个窗口，接收方和发送方的窗口大小并不一定保持一样大</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/1/160b085bd076c24e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>
<p>A的发送窗口的后沿变化情况有两种:</p>
<ul>
<li>不动.说明没有收到新的确认.</li>
<li>向前移动.说明收到了新的确认.</li>
<li>不可能出现向后移动,若向后移动代表确认过的报文需要再次确认,这是不存在的.</li>
</ul>
<p>A的发送窗口的前沿通常不断向前移动,但可能不动:</p>
<ul>
<li>未收到新的确认,B通知的窗口大小也未变化.</li>
<li>收到新的确认,但B的窗口缩小,刚好使A的发送窗口不动.</li>
</ul>
<p>上图中，如果a收到了确认好31，则表示30之前的数据都正确到达b，但是如果现在，b收到了序号为32,33的数据，没有收到31，给a发出的确认号只能是31，直到正确接收到31为止</p>
<p><strong>超时重传时间的选择</strong></p>
<p>超时重传是保证TCP可靠的重要举措, 这个时间时如何确定的呢?</p>
<p>TCP采用了自适应的算法: 它会记录一个报文发出去的时间,和接收到相应确认的时间.这两个时间之差就是报文段的往返时间RTT.TCP还会保留RTT的加权平均RTTs.当第一次获取到RTT时,RTTs的值也是这个,以后每次获取到RTT后,就会重新计算</p>
<p>RTTs:</p>
<pre><code>新的RTTs = (1-x) *  旧RTTs + x * 新RTT值</code></pre><p>复制代码超时重传时间(RTO, retransmissionTime-Out)应略大于RTTs,具体更详细的计算,这里就不再展开.</p>
<h5 id="2-基于滑动窗口的流量控制"><a href="#2-基于滑动窗口的流量控制" class="headerlink" title="2.基于滑动窗口的流量控制"></a>2.基于滑动窗口的流量控制</h5><p>流量控制,控制的流量是发送方发出的流量,不至于发的数据太多,接收方来不及接收.TCP基于滑动窗口很容易实现流量控制.借用下图理解下:</p>
<p><img src="https://img-blog.csdnimg.cn/20190803163236767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>在建立连接时,接收方(B),告诉了发送方(A):我的接收窗口是400(单位字节).</p>
</li>
<li><p>图中的ACK为TCP首部的ACK字段,ack为首部的确认号字段.</p>
</li>
<li><p>流量控制体现在:rwnd=300, rwnd=100, rwnd=0.在确认报文的窗口字段设定了发送方能够发出的数据多少,从而控制流量.注意只有到首部的ACK字段值为1,窗口字段的值才有效.</p>
</li>
<li><p>假设在B发送了rwnd=0之后,过段时间由于自己又希望接收到数据,于是发出rwnd=400的报文,但是该报文丢失了,这样A依然无法发送数据,B希望接收但接收不到数据.<br>为解决该问题,TCP为每个链接都设有一个持续计时器.只要接收到对方窗口为0的通知,就启动持续计时器.在计时器到期后,就发送探测报文,对方可以在该报文的确认中告知当前的窗口值.若窗口任然为0,那么就重新设定计时器,若不为0,那么上述的问题就解决了</p>
</li>
</ul>
<h5 id="3-tcp拥塞控制"><a href="#3-tcp拥塞控制" class="headerlink" title="3.tcp拥塞控制"></a>3.tcp拥塞控制</h5><p>实现tcp拥塞控制：</p>
<ul>
<li>慢开始</li>
<li>拥塞避免</li>
<li>快重传</li>
<li>快恢复</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190803163501318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li><p>慢开始.当连接建立开始传递数据时,由于不清楚网络状况,先将较小数据发送出去,有小到大的增加发送窗口.比如先发送一个字节数据,等收到确认后再发送2个字节…4个等.每经过一次确认就将发送窗口加倍.</p>
</li>
<li><p>图中的ssthresh为慢开始门限,在慢开始的作用下,发送窗口成倍增加,不可能没有上限,这个上限就是慢开始门限.慢开始门限以下使用慢开始控制发送窗口,而在慢开始门限以上使用避免拥塞方法.</p>
</li>
<li><p>拥塞避免思路是在经过确认后,每次将发送窗口增加1,而不是像慢开始那样成倍增加.</p>
</li>
<li><p>发送窗口还继续增大,直到标注的2,网络出现超时,发送方判断出现了拥塞,将慢开始门限设置为发送窗口值的一半,同时将发送窗口设为1,进入慢开始.</p>
</li>
<li><p>当再次到达慢开始门限时(标注3),执行避免拥塞控制,直到标注4.此时出现了对一个报文3次确认的情况(如图中标注3-ACK).</p>
<p> 在个别报文丢失(而不是网络拥塞),发送方收不到确认,误以为网络拥塞.<br>快重传可以让发送方尽早知道报文丢失.它要求接收方要对收到的数据尽快确认.即使收到了未按序到达的数据,也要对之前确认过的报文再次确认.这样就不会超时,也不会造成发送方误解网络拥塞.<br>上图标注的3-ACK就是连续的3次重复确认.</p>
</li>
</ol>
<pre><code>到标注4后,发送方知道了网络未出现拥塞, 便启用快恢复控制,将门限值调整为发送窗口的一半,发送窗口也减半.开始避免拥塞控制.当然这只是一种快恢复的方法.</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/1/1/160b0886dddba97e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kevin091827.github.io/2019/08/02/tcp-and-udp/" data-id="cjz54ryh1001okwu3d62nxdno"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机网络/">计算机网络</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
        <article id="post-应用层协议" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/08/01/应用层协议/">应用层协议</a>
    </h2>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/08/01/应用层协议/" class="article-date">
  <time datetime="2019-08-01T06:16:39.000Z" itemprop="datePublished">2019-08-01</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h1 id="一，应用层规范"><a href="#一，应用层规范" class="headerlink" title="一，应用层规范"></a>一，应用层规范</h1><p>应用层的具体内容就是精确定义这些通信规定</p>
<ul>
<li>应用进程交换的报文类型，如请求报文和响应报文</li>
<li>各种报文类型的语法，如报文中的各个字段及其详细描述</li>
<li>字段的语义，即包含在字段中的信息含义</li>
<li>进程何时，如何发送报文，以及对报文进行响应的规则</li>
</ul>
<h1 id="二，应用层协议"><a href="#二，应用层协议" class="headerlink" title="二，应用层协议"></a>二，应用层协议</h1><h2 id="1-域名系统DNS"><a href="#1-域名系统DNS" class="headerlink" title="1.域名系统DNS"></a>1.域名系统DNS</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>互联网的命名系统，将人们便于记住的名字转为ip地址，为网络应用提供核心服务</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>将互联网上的主机名字解析为ip地址</p>
<p><strong>补充</strong></p>
<ol>
<li><p>为什么机器在处理ip数据报时要使用ip地址而不使用域名呢？</p>
<p> ip地址的长度是固定的32位，如果是ipv6地址，则是固定的128位，长度固定，但是域名是便于用户记忆，长度一般是不固定的，机器处理起来比较困难</p>
</li>
</ol>
<h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><p>宏观：</p>
<p><img src="https://img-blog.csdnimg.cn/2019080114381298.png" alt="在这里插入图片描述"></p>
<p>递归查询和迭代查询：</p>
<ol>
<li><p>主机向本地域名服务器的查询一般都是采用递归查询。</p>
<p> 所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。</p>
</li>
</ol>
<ol start="2">
<li><p>本地域名服务器向根域名服务器的查询的迭代查询。</p>
<p> 迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20190801144254752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>全：</p>
<p><img src="https://img-blog.csdnimg.cn/20190801145004558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>补充问题：</strong></p>
<p>为什么域名解析请求和响应过程都是基于UDP协议？</p>
<h2 id="2-FTP简单文件传输协议"><a href="#2-FTP简单文件传输协议" class="headerlink" title="2.FTP简单文件传输协议"></a>2.FTP简单文件传输协议</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>文件传输协议ftp是基于tcp协议的文件传输服务。提供对远程计算机文件的增删改查操作，主要是为了减少或者消除在不同操作系统上处理文件的不兼容性</p>
<p>这些不兼容性体现在：</p>
<ul>
<li>计算机存储数据的格式不同</li>
<li>文件的目录结构和文件命名的规定不同</li>
<li>对于相同的文件存取功能，操作系统使用的命令不同</li>
<li>访问控制的方法不同</li>
</ul>
<p>ftp工作流程：</p>
<p><img src="https://img-blog.csdnimg.cn/20190801151955981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>数据传输：</p>
<p><img src="https://img-blog.csdnimg.cn/20190801152355766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>补充问题：</strong></p>
<ol>
<li><p>为什么建立两个独立连接？</p>
<p> 使协议更加简单，容易实现，同时在传输文件时还可以利用控制连接对文件传输进行控制</p>
</li>
</ol>
<h2 id="3-http协议"><a href="#3-http协议" class="headerlink" title="3.http协议"></a>3.http协议</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>http协议是一个基于tcp/ip的应用层协议，是一种详细规定了浏览器和万维网(WWW = World Wide Web)服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。</p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="https://img-blog.csdnimg.cn/20190801153817250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>一次HTTP操作称为一个事务，所以也称http是面向事务的协议</p>
<p>所以一次http请求的时间 = 2*往返rtt + 文档传输时间</p>
<p><strong>特点：</strong></p>
<ol>
<li><p>简单快速：客户向服务器请求服务时，只需要传送请求方法和路径，请求方法常用的有get，post，每种方法规定了客户和服务器联系的类型不同，由于http协议简单，使得http服务器程序规模小，通信速度快</p>
</li>
<li><p>灵活：http允许传输任意类型的数据对象，正在传输的类型由content-type加以标记</p>
</li>
<li><p>无连接：每次连接只处理一个请求。服务器处理完客户端的请求并收到客户端的回应后就断开连接，采取这种方式可以节省传输时间，http1.1版本支持可持续连接</p>
</li>
<li><p>无状态：http是无状态协议，无状态是指协议对事务处理没有记忆能力，对于后续请求如果需要用到前面的信息，则他必须重新传，这样可能导致每次连接传输的数据量增大，另一方面，在服务器不需要先前信息时，应答就比较快</p>
</li>
</ol>
<h3 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h3><p>请求报文格式：</p>
<p><img src="https://s1.51cto.com/images/20180426/1524747772856125.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt></p>
<p>响应报文格式：</p>
<p><img src="https://s1.51cto.com/images/20180426/1524748488887423.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt></p>
<p>请求和响应报文的不同之处在于请求行和响应行</p>
<p>在请求行中比较重要的就是请求方法：</p>
<ul>
<li>get ：  从服务器获取资源    </li>
<li>post  ：请求修改服务器资源</li>
<li>put   ：向服务器上传资源</li>
<li>delete  ：  删除服务器资源</li>
<li>head     ： 获得服务器文档首部</li>
</ul>
<p>在响应行中最重要的就是状态码：</p>
<ul>
<li>1xx    ：表示HTTP请求已经接受，继续处理请求</li>
<li>2xx    ：表示HTTP请求已经处理完成</li>
<li>3xx    ：表示把请求访问的URL重定向到其他目录</li>
<li>4xx    ：表示客户端出现错误</li>
<li>5xx    ：表示服务端出现错误</li>
</ul>
<p>常见状态码：</p>
<ul>
<li>200 OK ： 请求处理成功</li>
<li>301 MOVE PERMANENTLY ；永久跳转</li>
<li>403 FORBIDDEN ：客户端无权限访问</li>
<li>404 NOT FOUND：服务器找不到响应资源</li>
<li>500 INTERNAL SERVER ERROR : 服务器出错</li>
<li>502 BAD GATEWAY ：后端没有按照http协议返回响应</li>
<li>503 SERVICE UNAVALIBILE ：服务不可用</li>
<li>504 GATEWAY TIMEOUT : 请求超时</li>
</ul>
<p>http响应模型：</p>
<p>服务器收到HTTP请求之后，会有多种方法响应这个请求，下面是HTTP响应的四种模型：</p>
<ul>
<li><p>单进程I/O模型</p>
<p>  服务端开启一个进程，一个进程仅能处理一个请求，并且对请求顺序处理；</p>
</li>
<li><p>多进程I/O模型</p>
<p>  服务端并行开启多个进程，同样的一个进程只能处理一个请求，这样服务端就可以同时处理多个请求；</p>
</li>
<li><p>复用I/O模型</p>
<p>  服务端开启一个进程，但是呢，同时开启多个线程，一个线程响应一个请求，同样可以达到同时处理多个请求，线程间并发执行；</p>
</li>
<li><p>复用多线程I/O模型</p>
<p>  服务端并行开启多个进程，同时每个进程开启多个线程，这样服务端可以同时处理进程数M*每个进程的线程数N个请求。</p>
</li>
</ul>
<h3 id="session和cookie"><a href="#session和cookie" class="headerlink" title="session和cookie"></a>session和cookie</h3><p>cookie原理：</p>
<p><img src="https://img-blog.csdnimg.cn/20190801163401145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>session原理：</p>
<p><img src="https://img-blog.csdnimg.cn/2019080116352992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>区别：</p>
<ul>
<li>session是服务器端技术，数据保存在服务器端，cookie是客户端技术，数据保存在客户端文件</li>
<li>session的安全性高于cookie</li>
<li>session保存在服务端，当服务端访问增多时，会比较占用性能</li>
</ul>
<h3 id="http版本比较"><a href="#http版本比较" class="headerlink" title="http版本比较"></a>http版本比较</h3><p><img src="https://img-blog.csdnimg.cn/20190801164239808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="4-https"><a href="#4-https" class="headerlink" title="4.https"></a>4.https</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>http是超文本安全传输协议，由于http在网络上是明文传输，可能会被拦截，而https是加密传输，加密和解密工作交由ssl完成</p>
<p>区别：</p>
<p><img src="https://img-blog.csdnimg.cn/20190801164954575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190801165219965.png" alt="在这里插入图片描述"></p>
<p>HTTPS和HTTP的区别主要为以下四点：</p>
<ul>
<li>一、https协议需要到ca申请证书，一般免费证书很少，需要交费。</li>
<li>二、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。</li>
<li>三、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>四、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ul>
<h3 id="ssl加密解密"><a href="#ssl加密解密" class="headerlink" title="ssl加密解密"></a>ssl加密解密</h3><p>加密方法：</p>
<p><strong>对称加密：</strong></p>
<p>对称加密原理：</p>
<ul>
<li>对称加密靠秘钥来进行加密，也靠同一个秘钥来进行解密</li>
</ul>
<p>常用的对称加密算法：</p>
<ul>
<li>DES</li>
<li>3DES</li>
<li>AES</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AES加密</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">    String result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE,getSecretKey());</span><br><span class="line">        result = <span class="keyword">new</span> String(cipher.doFinal(data.getBytes(<span class="string">"utf-8"</span>)));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AES解密</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">    String result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE,getSecretKey());</span><br><span class="line">        result = <span class="keyword">new</span> String(cipher.doFinal(data.getBytes(<span class="string">"utf-8"</span>)));</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得加密和解密所需的密钥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SecretKey <span class="title">getSecretKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SecretKey secretKey = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        SecureRandom secureRandom = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">        keyGenerator.init(secureRandom);</span><br><span class="line">        secretKey = keyGenerator.generateKey();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> secretKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对称加密算法的优缺点：</p>
<ul>
<li>优点：计算量相对较小，可以处理数据量较大的数据的加密工作</li>
<li>缺点：密钥容易泄露，且服务器管理密钥比较麻烦</li>
</ul>
<p><strong>非对称加密</strong></p>
<p>非对称加密原理：</p>
<ul>
<li>非对称加密靠公钥来进行加密，靠私钥来进行解密</li>
</ul>
<p>常见的非对称加密算法：</p>
<ul>
<li>rsa加密算法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RSA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] publicEncrytype(String data,PublicKey publicKey)&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE,publicKey);</span><br><span class="line">            result = cipher.doFinal(data.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥解密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">privateDecrytypr</span><span class="params">(<span class="keyword">byte</span>[] data,PrivateKey privateKey)</span></span>&#123;</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE,privateKey);</span><br><span class="line">            result = <span class="keyword">new</span> String(cipher.doFinal(data),<span class="string">"utf-8"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PublicKey <span class="title">getPublicKey</span><span class="params">(KeyPair keyPair)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keyPair.getPublic();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PrivateKey <span class="title">getPrivateKey</span><span class="params">(KeyPair keyPair)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keyPair.getPrivate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得密钥对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> KeyPair <span class="title">getKeyPair</span><span class="params">()</span></span>&#123;</span><br><span class="line">        KeyPair keyPair = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">            SecureRandom secureRandom = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">            keyPairGenerator.initialize(<span class="number">64</span>,secureRandom);</span><br><span class="line">            keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keyPair;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非对称加密优缺点：</p>
<ul>
<li>优点：数据传输安全</li>
<li>缺点：计算量大，加密和解密速度较慢</li>
</ul>
<h3 id="https工作流程"><a href="#https工作流程" class="headerlink" title="https工作流程"></a>https工作流程</h3><p><img src="https://img-blog.csdnimg.cn/2019080118410042.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><a href="https://blog.csdn.net/liupeifeng3514/article/details/79840274" target="_blank" rel="noopener">https原理简单介绍</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://kevin091827.github.io/2019/08/01/应用层协议/" data-id="cjz54ryh9001vkwu3w4npzlt9"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机网络/">计算机网络</a></li></ul>

    </footer>

  </div>

  

  

</article>



      
  </article>
  

  
    <nav class="page-nav">
      
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next page</a>
    </nav>
  
</section>
</div>

  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
    <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2019 Kevin&#39;s blog</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>

<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="Kevin&#39;s blog"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>

<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>

<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
<script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/snap.svg-min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/ocean.js"></script>

</body>
</html>