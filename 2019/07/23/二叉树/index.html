<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    二叉树 |
    
    Kevin&#39;s blog</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="outer">
  <article id="post-二叉树" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      二叉树
    </h1>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2019/07/23/二叉树/" class="article-date">
  <time datetime="2019-07-23T15:36:33.000Z" itemprop="datePublished">2019-07-23</time>
</a>
        
      </div>
    

    <div class="article-entry" itemprop="articleBody">
      

      

      
        <h1 id="一，树的基本知识"><a href="#一，树的基本知识" class="headerlink" title="一，树的基本知识"></a>一，树的基本知识</h1><h2 id="1-树的递归定义"><a href="#1-树的递归定义" class="headerlink" title="1.树的递归定义"></a>1.树的递归定义</h2><ul>
<li>空结构是一棵空树</li>
<li>如果 t1 t2 … tn是不相交的树，那么以t1 t2… tn的根为子节点的数据结构也是一棵树</li>
<li>只有经过1,2步骤产生的数据结构才算是树</li>
</ul>
<h2 id="2-树的基本知识"><a href="#2-树的基本知识" class="headerlink" title="2.树的基本知识"></a>2.树的基本知识</h2><p><strong>树的分类</strong></p>
<p>树其实总体可以分为两类：</p>
<ul>
<li>二叉树</li>
<li>多叉树</li>
</ul>
<p>在二叉树中其实还有很多种</p>
<ul>
<li>二叉搜索树</li>
<li>二叉线索树</li>
<li>二叉平衡树</li>
</ul>
<p>我们在本文中先关注最基本的二叉树</p>
<p><strong>二叉树的基本性质</strong></p>
<p>二叉树可以分为</p>
<ul>
<li>普通的非空二叉树</li>
<li>完全二叉树</li>
<li>满二叉树</li>
</ul>
<p>层数 = 路径数 + 1 （根的层数是 1 ）</p>
<p>第 i 层最多节点数 = 2^i </p>
<p>第 i 层的节点数 ：</p>
<ul>
<li>完全二叉树： 2^(i-1)</li>
<li>满二叉树:   2^i - 1</li>
</ul>
<p>高度和深度：</p>
<p>二叉树的深度是从根节点开始（其深度为1）自顶向下逐层累加的；而二叉树高度是从叶节点开始（其高度为1）自底向上逐层累加的。虽然树的深度和高度一样，但是具体到树的某个节点，其深度和高度是不一样的。</p>
<h1 id="二，二叉树"><a href="#二，二叉树" class="headerlink" title="二，二叉树"></a>二，二叉树</h1><p>二叉树是节点可以包含两个子节点，也可能两个子节点为空，每一个子节点都可以区分为左子节点和右子节点</p>
<p>二叉树的一个性质就是一棵平均二叉树的深度要比节点个数N小得多，平均深度为 O（根号N）</p>
<h2 id="1-二叉树实现"><a href="#1-二叉树实现" class="headerlink" title="1.二叉树实现"></a>1.二叉树实现</h2><p>节点类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:    节点类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>:         Kevin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateDate</span>:     2019/7/24 0:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@UpdateUser</span>:     Kevin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@UpdateDate</span>:     2019/7/24 0:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@UpdateRemark</span>:   修改内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> element;</span><br><span class="line">    <span class="comment">//左子节点</span></span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode left;</span><br><span class="line">    <span class="comment">//右子节点</span></span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span><span class="params">(<span class="keyword">int</span> element,BinaryTreeNode left,BinaryTreeNode right)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryTreeNode</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setElement</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(BinaryTreeNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(BinaryTreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现二叉树：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:    二叉树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>:         Kevin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateDate</span>:     2019/7/24 0:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@UpdateUser</span>:     Kevin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@UpdateDate</span>:     2019/7/24 0:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@UpdateRemark</span>:   修改内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">private</span> BinaryTreeNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BinaryTreeNode <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(BinaryTreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-二叉树的相关算法"><a href="#2-二叉树的相关算法" class="headerlink" title="2.二叉树的相关算法"></a>2.二叉树的相关算法</h2><h3 id="1-遍历"><a href="#1-遍历" class="headerlink" title="1.遍历"></a>1.遍历</h3><p>二叉树的遍历是一个很重要的算法，其递归和非递归实现都需要掌握</p>
<h4 id="1-深度优先遍历"><a href="#1-深度优先遍历" class="headerlink" title="1.深度优先遍历"></a>1.深度优先遍历</h4><h5 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="1.前序遍历"></a>1.前序遍历</h5><p>递归实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历 --- 递归实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(root.getElement());</span><br><span class="line">        preOrder(root.getLeft());</span><br><span class="line">        preOrder(root.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历 --- 非递归实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder2</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">    BinaryTreeNode p = root;</span><br><span class="line">    Stack&lt;BinaryTreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(p);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        BinaryTreeNode node = stack.pop();</span><br><span class="line">        <span class="keyword">int</span> element = node.getElement();</span><br><span class="line">        resultList.add(element);</span><br><span class="line">        <span class="keyword">if</span>(node.getRight() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(node.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.getLeft() != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(node.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : resultList)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BinaryTreeNode root = <span class="keyword">new</span> BinaryTreeNode(<span class="number">15</span>);</span><br><span class="line">    BinaryTreeNode r1 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">4</span>);</span><br><span class="line">    BinaryTreeNode r2 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">1</span>);</span><br><span class="line">    BinaryTreeNode r3 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">20</span>);</span><br><span class="line">    BinaryTreeNode r4 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">16</span>);</span><br><span class="line">    BinaryTreeNode r5 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">25</span>);</span><br><span class="line">    BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">    binaryTree.setRoot(root);</span><br><span class="line">    root.setLeft(r1);</span><br><span class="line">    root.setRight(r3);</span><br><span class="line">    r1.setLeft(r2);</span><br><span class="line">    r3.setLeft(r4);</span><br><span class="line">    r3.setRight(r5);</span><br><span class="line">    System.out.println(<span class="string">"********前序遍历递归**********"</span>);</span><br><span class="line">    binaryTree.preOrder(root);</span><br><span class="line">    System.out.println(<span class="string">"********前序遍历非递归**********"</span>);</span><br><span class="line">    binaryTree.preOrder2(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2.中序遍历"></a>2.中序遍历</h5><p>递归实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历 --- 递归实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        inOrder(root.getLeft());</span><br><span class="line">        System.out.println(root.getElement());</span><br><span class="line">        inOrder(root.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历 --- 非递归实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder2</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;BinaryTreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    BinaryTreeNode p = root;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">           stack.push(p);</span><br><span class="line">           p = p.getLeft();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            p = stack.pop();</span><br><span class="line">            resultList.add(p.getElement());</span><br><span class="line">            p = p.getRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : resultList)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">BinaryTreeNode root = <span class="keyword">new</span> BinaryTreeNode(<span class="number">15</span>);</span><br><span class="line">BinaryTreeNode r1 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">4</span>);</span><br><span class="line">BinaryTreeNode r2 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">1</span>);</span><br><span class="line">BinaryTreeNode r3 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">20</span>);</span><br><span class="line">BinaryTreeNode r4 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">16</span>);</span><br><span class="line">BinaryTreeNode r5 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">25</span>);</span><br><span class="line">BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">binaryTree.setRoot(root);</span><br><span class="line">root.setLeft(r1);</span><br><span class="line">root.setRight(r3);</span><br><span class="line">r1.setLeft(r2);</span><br><span class="line">r3.setLeft(r4);</span><br><span class="line">r3.setRight(r5);</span><br><span class="line">System.out.println(<span class="string">"********中序遍历递归**********"</span>);</span><br><span class="line">binaryTree.inOrder(root);</span><br><span class="line">System.out.println(<span class="string">"********中序遍历非递归**********"</span>);</span><br><span class="line">binaryTree.inOrder2(root);</span><br></pre></td></tr></table></figure>

<h5 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3.后序遍历"></a>3.后序遍历</h5><p>递归实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历 --- 递归实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">proOrder</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        proOrder(root.getLeft());</span><br><span class="line">        proOrder(root.getRight());</span><br><span class="line">        System.out.println(root.getElement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历 --- 非递归实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">proOrder2</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    BinaryTreeNode p = root;</span><br><span class="line">    <span class="comment">//操作栈</span></span><br><span class="line">    Stack&lt;BinaryTreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">//结果栈，用于存放后序遍历的结果</span></span><br><span class="line">    Stack&lt;BinaryTreeNode&gt; resultStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            resultStack.push(p);</span><br><span class="line">            p = p.getRight();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p = stack.pop();</span><br><span class="line">            p = p.getLeft();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!resultStack.isEmpty())&#123;</span><br><span class="line">        BinaryTreeNode node = resultStack.pop();</span><br><span class="line">        resultList.add(node.getElement());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : resultList)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BinaryTreeNode root = <span class="keyword">new</span> BinaryTreeNode(<span class="number">15</span>);</span><br><span class="line">    BinaryTreeNode r1 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">4</span>);</span><br><span class="line">    BinaryTreeNode r2 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">1</span>);</span><br><span class="line">    BinaryTreeNode r3 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">20</span>);</span><br><span class="line">    BinaryTreeNode r4 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">16</span>);</span><br><span class="line">    BinaryTreeNode r5 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">25</span>);</span><br><span class="line">    BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">    binaryTree.setRoot(root);</span><br><span class="line">    root.setLeft(r1);</span><br><span class="line">    root.setRight(r3);</span><br><span class="line">    r1.setLeft(r2);</span><br><span class="line">    r3.setLeft(r4);</span><br><span class="line">    r3.setRight(r5);</span><br><span class="line">    System.out.println(<span class="string">"********后序遍历递归**********"</span>);</span><br><span class="line">    binaryTree.proOrder(root);</span><br><span class="line">    System.out.println(<span class="string">"********后序遍历非递归**********"</span>);</span><br><span class="line">    binaryTree.proOrder2(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-广度优先遍历"><a href="#2-广度优先遍历" class="headerlink" title="2.广度优先遍历"></a>2.广度优先遍历</h4><h5 id="1-层次遍历"><a href="#1-层次遍历" class="headerlink" title="1.层次遍历"></a>1.层次遍历</h5><p>非递归实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 广度优先遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathFirst</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;BinaryTreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            root = queue.remove();</span><br><span class="line">            resultList.add(root.getElement());</span><br><span class="line">            <span class="keyword">if</span>(root.getLeft() != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(root.getLeft());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.getRight() != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(root.getRight());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : resultList)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BinaryTreeNode root = <span class="keyword">new</span> BinaryTreeNode(<span class="number">15</span>);</span><br><span class="line">    BinaryTreeNode r1 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">4</span>);</span><br><span class="line">    BinaryTreeNode r2 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">1</span>);</span><br><span class="line">    BinaryTreeNode r3 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">20</span>);</span><br><span class="line">    BinaryTreeNode r4 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">16</span>);</span><br><span class="line">    BinaryTreeNode r5 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">25</span>);</span><br><span class="line">    BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">    binaryTree.setRoot(root);</span><br><span class="line">    root.setLeft(r1);</span><br><span class="line">    root.setRight(r3);</span><br><span class="line">    r1.setLeft(r2);</span><br><span class="line">    r3.setLeft(r4);</span><br><span class="line">    r3.setRight(r5);</span><br><span class="line">    System.out.println(<span class="string">"********层序遍历非递归**********"</span>);</span><br><span class="line">      binaryTree.breathFirst(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充：</p>
<ul>
<li>先序跟后序遍历不能确定一棵二叉树</li>
<li>中序遍历和前序遍历可以确定一棵二叉树</li>
</ul>
<h3 id="2-计算二叉树的深度"><a href="#2-计算二叉树的深度" class="headerlink" title="2.计算二叉树的深度"></a>2.计算二叉树的深度</h3><p><strong>二叉树深度：</strong></p>
<ul>
<li>空树的深度是 0 </li>
<li>只有根节点，深度为 0</li>
<li>根节点只有左子树而没有右子树，二叉树的深度 = 左子树深度 + 1</li>
<li>根节点只有右子树而没有右子树，二叉树的深度 = 右子树深度 + 1</li>
<li>根节点又有右子树又有左子树，二叉树深度 = 左右子树深度较大值 + 1</li>
</ul>
<p>递归实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h&gt;计算二叉树深度&lt;/h&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;1、一颗树只有一个节点，它的深度是 1&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;2、二叉树的根节点只有左子树而没有右子树，二叉树的深度应该是其左子树的深度加 1&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;3、二叉树的根节点只有右子树而没有左子树，那么二叉树的深度应该是其右树的深度加 1&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;4、二叉树的根节点既有右子树又有左子树，那么二叉树的深度应该是其左右子树的深度较大值加 1&lt;/li&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 【递归实现】</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthOfBinaryTree</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(depthOfBinaryTree(root.getLeft()),depthOfBinaryTree(root.getRight()))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归实现：其实就是广度优先遍历二叉树，找到最深左子树或者右子树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;h&gt;计算二叉树深度&lt;/h&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 【非递归实现】</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthOfBinaryTree2</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayDeque&lt;BinaryTreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            BinaryTreeNode node = queue.removeFirst();</span><br><span class="line">            <span class="keyword">if</span>(node.getLeft() != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(node.getLeft());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.getRight() != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.add(node.getRight());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二叉树深度的性质</strong></p>
<ul>
<li><p>一个深度为 k 的二叉树，最多具有 2^（k-1）个节点</p>
<ul>
<li>具有2^k-1个节点的是满二叉树</li>
</ul>
</li>
<li><p>具有n个结点的完全二叉树的深度是【log2n】+1（向下取整）    </p>
</li>
</ul>
<h3 id="3-计算二叉树的节点个数"><a href="#3-计算二叉树的节点个数" class="headerlink" title="3.计算二叉树的节点个数"></a>3.计算二叉树的节点个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算二叉树的节点数</span></span><br><span class="line"><span class="comment"> * 【递归】</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nodeNum</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//根节点 + 根左子树的节点数 + 根右子树的节点数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+nodeNum(root.getRight())+nodeNum(root.getLeft());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-镜像二叉树"><a href="#4-镜像二叉树" class="headerlink" title="4.镜像二叉树"></a>4.镜像二叉树</h3><p><img src="https://files.jb51.net/file_images/article/201711/20171120113408486.png?20171020113419" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 镜像二叉树</span></span><br><span class="line"><span class="comment"> * 【递归实现】</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mirror</span><span class="params">(BinaryTreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span> &amp;&amp;(root.getLeft() != <span class="keyword">null</span> || root.getRight() != <span class="keyword">null</span>))&#123;</span><br><span class="line">        <span class="comment">//交换左右节点</span></span><br><span class="line">        BinaryTreeNode left = root.getLeft();</span><br><span class="line">        BinaryTreeNode right = root.getRight();</span><br><span class="line">        BinaryTreeNode tmp = root.getLeft();</span><br><span class="line">        left = root.getRight();</span><br><span class="line">        right = tmp;</span><br><span class="line">        <span class="comment">//递归镜像左右子树</span></span><br><span class="line">        mirror(root.getLeft());</span><br><span class="line">        mirror(root.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://kevin091827.github.io/2019/07/23/二叉树/" data-id="cjz54ryh2001pkwu3pztc0g2p"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构和算法/">数据结构和算法</a></li></ul>

    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2019/07/25/二叉搜索树/" class="article-nav-link">
        <strong class="article-nav-caption">Newer posts</strong>
        <div class="article-nav-title">
          
            二叉搜索树
          
        </div>
      </a>
    
    
      <a href="/2019/07/23/递归/" class="article-nav-link">
        <strong class="article-nav-caption">Olde posts</strong>
        <div class="article-nav-title">递归</div>
      </a>
    
  </nav>


  

  
    
  

</article>



</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
    <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2019 Kevin&#39;s blog</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>

<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="Kevin&#39;s blog"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>

<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>

<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
<script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/snap.svg-min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/ocean.js"></script>

</body>
</html>